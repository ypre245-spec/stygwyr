<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PhotoBooth Pro</title>
    
    <!-- APP ICONS -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect x=%2210%22 y=%2225%22 width=%2280%22 height=%2260%22 rx=%2210%22 ry=%2210%22 fill=%22%234a90e2%22/><circle cx=%2250%22 cy=%2255%22 r=%2220%22 fill=%22%23222%22 stroke=%22white%22 stroke-width=%226%22/><rect x=%2230%22 y=%2210%22 width=%2240%22 height=%2215%22 rx=%225%22 ry=%225%22 fill=%22%234a90e2%22/><circle cx=%2275%22 cy=%2240%22 r=%225%22 fill=%22white%22/></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 fill=%22%23121212%22/><rect x=%2210%22 y=%2225%22 width=%2280%22 height=%2260%22 rx=%2210%22 ry=%2210%22 fill=%22%234a90e2%22/><circle cx=%2250%22 cy=%2255%22 r=%2220%22 fill=%22%23222%22 stroke=%22white%22 stroke-width=%226%22/><rect x=%2230%22 y=%2210%22 width=%2240%22 height=%2215%22 rx=%225%22 ry=%225%22 fill=%22%234a90e2%22/><circle cx=%2275%22 cy=%2240%22 r=%225%22 fill=%22white%22/></svg>">

    <!-- MediaPipe for AI Background Blur & Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

    <style>
        /* General Setup */
        :root {
            --brand-color: #4a90e2;
            --brand-gradient: linear-gradient(135deg, #4a90e2, #9b59b6);
            --dark-bg: #121212;
            --card-bg: #1e1e1e;
            --light-text: #f0f0f0;
            --shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            --panel-bg: rgba(30, 30, 30, 0.95);
        }

        html, body {
            margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden;
            background-color: var(--dark-bg); color: var(--light-text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overscroll-behavior: none;
        }

        /* View Management */
        .view {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: none; box-sizing: border-box; align-items: center; justify-content: center;
        }

        /* --- LOGIN VIEW --- */
        #login-view {
            flex-direction: column;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            z-index: 999;
        }

        .login-container {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        
        .login-container.initial-slide {
            animation: slide-up 0.6s ease-out;
        }
        
        .login-container.error-shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
            border-color: #ff4d4d;
        }

        @keyframes slide-up {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        .login-logo svg { width: 60px; height: 60px; margin-bottom: 15px; filter: drop-shadow(0 0 10px rgba(74, 144, 226, 0.5)); }
        
        .login-title {
            font-size: 1.8em; font-weight: 700; margin: 0 0 25px 0;
            background: var(--brand-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .input-group { display: flex; flex-direction: column; gap: 15px; }
        
        #login-password {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            color: white;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 1em;
            text-align: center;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        #login-password:focus { outline: none; border-color: var(--brand-color); box-shadow: 0 0 10px rgba(74, 144, 226, 0.2); }

        #login-btn {
            background: var(--brand-gradient);
            border: none;
            padding: 12px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #login-btn:active { transform: scale(0.95); }

        .login-error { color: #ff4d4d; font-size: 0.85em; margin-top: 10px; height: 20px; opacity: 0; transition: opacity 0.3s; }

        /* Welcome Animation Overlay */
        #welcome-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black;
            display: none;
            align-items: center; justify-content: center;
            z-index: 1000;
            transition: transform 0.8s cubic-bezier(0.77, 0, 0.175, 1);
        }
        .welcome-content { text-align: center; }
        #welcome-icon { font-size: 4em; margin-bottom: 20px; animation: wave 1.5s infinite; display: inline-block; }
        
        #welcome-msg { 
            font-size: 2em; font-weight: 300; color: white; 
            min-height: 1.2em; 
        }
        
        .typing-cursor::after {
            content: '|';
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        .name-pop {
            display: inline-block;
            font-weight: 700; color: #4a90e2;
            opacity: 0;
            transform: scale(0.5);
            animation: pop-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes pop-in { to { opacity: 1; transform: scale(1); } }
        
        @keyframes wave { 0% { transform: rotate(0deg); } 10% { transform: rotate(14deg); } 20% { transform: rotate(-8deg); } 30% { transform: rotate(14deg); } 40% { transform: rotate(-4deg); } 50% { transform: rotate(10deg); } 60% { transform: rotate(0deg); } 100% { transform: rotate(0deg); } }

        /* --- HOME SCREEN UI --- */
        #template-view {
            flex-direction: column; padding: 20px; overflow-y: auto;
            background: radial-gradient(circle at top, #2a2a2a 0%, #121212 100%);
        }

        .hero-section {
            text-align: center; margin-bottom: 30px;
        }
        .hero-title {
            font-size: 2.5em; font-weight: 800; margin: 0;
            background: var(--brand-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            letter-spacing: -1px;
        }
        .hero-subtitle { color: #888; font-size: 1em; margin-top: 5px; font-weight: 400; }

        .settings-btn {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(255,255,255,0.1); border: none; border-radius: 50%;
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: white; transition: background 0.2s; z-index: 100;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .settings-btn:hover { background: rgba(255,255,255,0.2); }
        .settings-btn svg { width: 24px; height: 24px; fill: white; }

        .cards-container {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px; width: 100%; max-width: 900px;
        }

        .action-card {
            background: var(--card-bg); padding: 20px; border-radius: 16px;
            box-shadow: var(--shadow); display: flex; flex-direction: column; gap: 15px;
            border: 1px solid #333; transition: transform 0.2s;
        }
        .action-card:hover { transform: translateY(-2px); border-color: #555; }
        
        .card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .card-icon { color: #4a90e2; }
        .card-title { font-size: 1.1em; font-weight: 600; margin: 0; }
        
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        .action-btn {
            background: #2c2c2c; color: white; border: none; border-radius: 8px;
            padding: 15px; font-size: 0.9em; font-weight: 500; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; gap: 8px;
            transition: background 0.2s;
        }
        .action-btn:hover { background: #3d3d3d; }
        .action-btn svg { opacity: 0.8; width: 24px; height: 24px; }
        
        .btn-primary { background: var(--brand-color); color: white; width: 100%; padding: 12px; font-weight: 600; border-radius: 8px; border:none; cursor:pointer; }
        .btn-primary:hover { opacity: 0.9; }

        #template-input { display: none; }
        #auto-map-msg { color: #4cd964; font-weight: 600; text-align: center; font-size: 0.9em; display: none; margin-top: 10px; }
        #file-name { color: #888; font-size: 0.85em; text-align: center; margin-top: 5px; font-style: italic; }

        .creator-credit {
            margin-top: 40px; font-size: 0.75em; color: #555;
            text-transform: uppercase; letter-spacing: 1.5px; opacity: 0.7;
        }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 200;
            display: none; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }

        #confirm-modal {
            z-index: 300 !important;
        }

        .modal-content {
            background: #252525; padding: 25px; border-radius: 16px;
            width: 90%; max-width: 400px; color: white; box-shadow: var(--shadow);
            display: flex; flex-direction: column; gap: 15px; max-height: 90vh;
        }
        .modal-header { font-size: 1.2em; font-weight: 600; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center;}
        .modal-row { display: flex; justify-content: space-between; align-items: center; }
        
        .modal-footer { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            gap: 10px; 
            margin-top: 20px;
            border-top: 1px solid #333; 
            padding-top: 15px;
        }
        
        .qr-container { background: white; padding: 10px; border-radius: 8px; margin: 0 auto; display: flex; justify-content: center; }

        select, input {
            background: #333; border: 1px solid #555; color: white;
            padding: 8px; border-radius: 6px; font-size: 0.95em;
        }

        #mapping-view, #preview-view { 
            flex-direction: column; 
        }
        
        #mapping-container { position: relative; }
        #mapping-canvas { border: 2px dashed #555; cursor: crosshair; max-width: 95vw; max-height: 70vh; object-fit: contain; box-shadow: var(--shadow); touch-action: none; }
        .mapping-text { margin: 5px 0 10px 0; font-size: 1.1em; font-weight: 500; color: #ffcc00; text-align: center; }
        
        #mapping-toolbar {
            display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; justify-content: center;
        }
        .tool-btn {
            background: #333; border: 1px solid #555; color: white; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.85em; display: flex; align-items: center; gap: 5px;
        }
        .tool-btn.active { background: var(--brand-color); border-color: var(--brand-color); }
        .tool-btn:hover { background: #444; }

        #magnifier {
            position: absolute; pointer-events: none; border: 2px solid white; border-radius: 50%; 
            width: 100px; height: 100px; display: none; overflow: hidden; box-shadow: 0 0 10px black; z-index: 100;
            background: #000;
        }

        #mapping-controls-panel {
            background: #2c2c2c; padding: 12px; border-radius: 12px; margin-top: 10px; 
            display: flex; flex-direction: column; gap: 8px; align-items: center;
            border: 1px solid #444; box-shadow: var(--shadow); width: 90%; max-width: 400px;
        }
        #mapping-controls-panel.hidden { display: none !important; }
        .control-row { display: flex; gap: 12px; align-items: center; justify-content: center; width: 100%; flex-wrap: wrap; }
        .info-pill { background: #111; padding: 4px 10px; border-radius: 4px; font-size: 0.85em; color: #aaa; border: 1px solid #333; }
        #rotation-slider { accent-color: var(--brand-color); flex: 1; min-width: 100px; height: 20px; }
        .rot-display { font-family: monospace; color: var(--brand-color); width: 45px; text-align: right; font-weight: bold; }

        #camera-view {
            display: none;
            background: black;
        }

        #camera-top-bar { 
            position: absolute; /* Overlay */
            top: 0; left: 0;
            width: 100%; 
            height: 70px;
            padding: 10px 20px; 
            box-sizing: border-box; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            z-index: 25; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        .icon-btn { background: rgba(50, 50, 50, 0.6); backdrop-filter: blur(4px); color: white; border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s; }
        .icon-btn:hover { background: rgba(80, 80, 80, 0.8); }
        .icon-btn.active { background: var(--brand-color); border-color: var(--brand-color); opacity: 0.9; }
        
        #video-container { 
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; /* Behind controls */
            background: black; 
            overflow: hidden; 
        }

        #camera-bottom-bar {
            position: absolute; /* Overlay */
            bottom: 0; left: 0;
            width: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 70%, rgba(0,0,0,0) 100%);
            padding: 40px 0 30px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }

        #camera-controls { 
            position: relative;
            display: flex; 
            flex-wrap: wrap; 
            gap: 12px; 
            background: transparent; 
            padding: 0; 
            align-items: center; 
            justify-content: center; 
            width: 100%; 
            transition: opacity 0.3s, transform 0.3s; 
            margin-bottom: 20px;
        }

        #camera-controls.controls-hidden { opacity: 0; pointer-events: none; transform: scale(0.9); }
        
        .control-btn-small { background: rgba(50,50,50,0.6); backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #fff; position: relative; }
        .control-btn-small.active { background: var(--brand-color); border-color: var(--brand-color); }
        .toggle-label { font-size: 0.9em; display: flex; align-items: center; gap: 5px; cursor: pointer; color: white; user-select: none; text-shadow: 0 1px 3px black; }

        #video-preview, #ai-canvas { width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; transition: opacity 0.2s; }
        
        #grid-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none;
        }
        .grid-line { position: absolute; background: rgba(255, 255, 255, 0.5); box-shadow: 0 0 2px rgba(0,0,0,0.5); }
        .grid-h { width: 100%; height: 1px; left: 0; }
        .grid-v { height: 100%; width: 1px; top: 0; }
        
        #live-template-img { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 100%; max-height: 100%; width: auto; height: auto; z-index: 4; opacity: 0.5; pointer-events: none; display: none; }
        .mirrored { transform: scaleX(-1); }
        
        #crop-frame-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; pointer-events: none; z-index: 5; box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6); border: 1px solid rgba(255,255,255,0.8); }
        
        @keyframes countdown-pulse {
            0% { opacity: 0; transform: scale(0.5); } 20% { opacity: 1; transform: scale(1.2); } 50% { opacity: 1; transform: scale(1.0); } 100% { opacity: 0; transform: scale(1.5); }
        }
        @keyframes arrow-lift {
            0% { opacity: 0; transform: translateY(50px) scale(0.8); } 
            20% { opacity: 1; transform: translateY(0) scale(1.2); } 
            80% { opacity: 1; transform: translateY(-50px) scale(1); } 
            100% { opacity: 0; transform: translateY(-150px) scale(0.5); }
        }

        #capture-btn { 
            position: relative; z-index: 25; width: 80px; height: 80px; 
            background-color: rgba(255, 255, 255, 0.3); border: 5px solid white; 
            border-radius: 50%; cursor: pointer; box-shadow: var(--shadow); 
            backdrop-filter: blur(2px);
        }
        #capture-btn:active { transform: scale(0.95); background-color: rgba(255,255,255,0.5); }
        #capture-btn::before { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60px; height: 60px; background: white; border-radius: 50%; }
        
        #photo-counter-overlay { position: absolute; top: 80px; right: 20px; background: rgba(0, 0, 0, 0.6); padding: 8px 14px; border-radius: 20px; font-size: 1em; font-weight: 600; z-index: 25; border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(4px); }
        #countdown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; justify-content: center; align-items: center; font-size: 25vmin; font-weight: bold; color: white; text-shadow: 0 0 20px rgba(0,0,0,0.7); z-index: 20; opacity: 0; }
        #countdown-overlay.animate { display: flex; animation: countdown-pulse 1s ease-in-out forwards; }
        #countdown-overlay.is-arrow.animate { animation: arrow-lift 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; }
        
        #photo-preview-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); max-width: 90vw; max-height: 90vh; display: none; object-fit: contain; z-index: 30; border-radius: 12px; opacity: 0; transition: transform 0.2s, opacity 0.2s; box-shadow: 0 10px 30px rgba(0,0,0,0.8); }
        #photo-preview-overlay.show-preview { display: block; opacity: 1; transform: translate(-50%, -50%) scale(1.1); }

        #captured-thumbnails {
            position: absolute; top: auto; bottom: 20px; left: 0; right: 0; width: 100%;
            display: flex; flex-direction: row; justify-content: center; gap: 10px;
            z-index: 35; max-height: 130px; overflow-x: auto; overflow-y: hidden;
            padding: 10px; pointer-events: none;
        }
        .cap-thumb {
            width: 130px; height: 95px; object-fit: cover; border: 2px solid rgba(255,255,255,0.7);
            border-radius: 6px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); background: #000;
            flex-shrink: 0; animation: thumb-slide-snap 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .cap-thumb.active-retake {
            border-color: var(--brand-color); transform: scale(1.1); box-shadow: 0 0 10px var(--brand-color);
        }
        
        @keyframes thumb-slide-snap {
            0% { opacity: 0; transform: translateX(50px) scale(0.8) rotate(5deg); }
            100% { opacity: 1; transform: translateX(0) scale(1) rotate(0deg); }
        }

        #zoom-container { display: none; align-items: center; gap: 5px; margin-left: 5px; padding-left: 5px; border-left: 1px solid rgba(255,255,255,0.3); }
        #zoom-slider { width: 80px; accent-color: var(--brand-color); cursor: pointer; }

        #preview-container { position: relative; max-width: 95vw; max-height: calc(100vh - 180px); margin: 0 auto; box-shadow: var(--shadow); border-radius: 8px; overflow: hidden; }
        #merge-canvas { display: block; max-width: 100%; max-height: 100%; height: auto; width: auto; }
        
        .button-group { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 10px; }
        .btn { padding: 10px 20px; font-size: 1em; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; transition: opacity 0.2s; box-shadow: var(--shadow); color: white; display: flex; align-items: center; gap: 5px; }
        .btn:hover { opacity: 0.85; }
        .btn:disabled { background-color: #555 !important; opacity: 0.7; }
        
        #retake-btn, #change-template-btn, #undo-btn, #redo-btn, #confirm-no, #lg-cancel-btn, #delete-slot-btn, #close-gallery-btn, #gallery-close-btn-footer, #close-preview-btn { background-color: #6c757d; }
        #remap-btn, #reset-mapping-btn { background-color: #dc3545; }
        #save-btn, #start-mapped-btn, #confirm-adjustment-btn, #confirm-yes, #gallery-btn, #print-btn { background-color: var(--brand-color); }
        #lg-create-btn { background-color: #28a745; }

        #gallery-modal .modal-content {
            width: 95%; max-width: 1000px; height: 85vh; 
            display: flex; flex-direction: column;
            padding: 15px;
        }
        .gallery-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px; overflow-y: auto; padding: 5px;
            flex: 1;
            align-content: start;
        }
        .gallery-item { 
            cursor: pointer; border: 2px solid transparent; border-radius: 6px; 
            overflow: hidden; transition: all 0.2s; position: relative; 
            aspect-ratio: 1; background: #000;
        }
        .gallery-item:hover { border-color: var(--brand-color); transform: scale(1.05); z-index: 2; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .gallery-empty { color: #666; text-align: center; margin-top: 50px; font-style: italic; grid-column: 1 / -1; }

        .gallery-delete-btn {
            position: absolute; top: 5px; right: 5px; width: 24px; height: 24px;
            background: rgba(220, 53, 69, 0.9); color: white; border: 2px solid white;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 16px; font-weight: bold; line-height: 1; cursor: pointer;
            opacity: 0; transition: opacity 0.2s, transform 0.2s; z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .gallery-item:hover .gallery-delete-btn { opacity: 1; }
        @media (hover: none) { .gallery-delete-btn { opacity: 0.8; } }
        .gallery-delete-btn:hover { transform: scale(1.2); background: #ff0000; }

        @keyframes delete-anim {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
        .gallery-item.deleting {
            animation: delete-anim 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            pointer-events: none; 
        }

        .lg-preview { width: 100%; height: 150px; background: #111; display: flex; align-items: center; justify-content: center; border: 1px dashed #555; margin-top: 10px; border-radius: 8px; }
        #lg-canvas-preview { max-width: 100%; max-height: 100%; object-fit: contain; }

        #kb-shortcuts-overlay { position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 0.7em; pointer-events: none; opacity: 0.5; }

        #flash-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; z-index: 9999; opacity: 0; pointer-events: none; display: none;
        }
        #flash-overlay.flash-active {
            display: block; animation: flash-anim 0.4s ease-out forwards;
        }
        @keyframes flash-anim {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        #notification-toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px);
            background: rgba(40, 167, 69, 0.95); color: white;
            padding: 8px 16px 8px 12px; border-radius: 30px; font-weight: 600;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 2000; opacity: 0;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s;
            pointer-events: auto; display: flex; align-items: center; gap: 12px;
            backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2);
            font-size: 0.95em; white-space: nowrap;
        }
        #notification-toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        #notification-toast.error { background: rgba(220, 53, 69, 0.95); }
        
        .toast-thumb {
            width: 32px; height: 32px; border-radius: 50%; object-fit: cover;
            border: 2px solid rgba(255,255,255,0.8); display: none;
        }
        .toast-action {
            margin-left: 5px; padding: 4px 10px; background: rgba(0,0,0,0.2);
            border-radius: 12px; cursor: pointer; font-size: 0.8em;
            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s;
        }
        .toast-action:hover { background: rgba(0,0,0,0.4); }

        .toast-undo {
            margin-left: 5px; padding: 4px 10px; background: rgba(255, 255, 255, 0.9);
            color: #333; border-radius: 12px; cursor: pointer; font-size: 0.8em;
            text-transform: uppercase; letter-spacing: 0.5px; font-weight: 800;
            transition: transform 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .toast-undo:hover { transform: scale(1.05); }

        body.powering-down {
            animation: turn-off 0.55s cubic-bezier(0.23, 1, 0.32, 1) forwards;
            pointer-events: none; 
        }
        
        @keyframes turn-off {
            0% { transform: scale(1, 1); filter: brightness(1); opacity: 1; }
            40% { transform: scale(1, 0.002); filter: brightness(2); opacity: 1; }
            100% { transform: scale(0, 0); filter: brightness(0); opacity: 0; }
        }

        /* NEW: Attract Screen */
        #attract-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 1500; display: none;
            cursor: pointer;
        }
        .attract-content {
            position: relative; width: 100%; height: 100%;
        }
        #attract-img {
            width: 100%; height: 100%; object-fit: cover;
            transition: opacity 1s ease-in-out;
            opacity: 0.6;
        }
        .attract-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
        }
        .attract-text {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            text-align: center; color: white; width: 100%;
        }
        .attract-text h1 {
            font-size: 1.5em; margin: 0; text-transform: uppercase; letter-spacing: 3px;
            animation: pulse-text 2s infinite; text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        @keyframes pulse-text { 0% { opacity: 0.7; transform: scale(1); } 50% { opacity: 1; transform: scale(1.05); } 100% { opacity: 0.7; transform: scale(1); } }

    </style>
</head>
<body>

    <!-- Attract Screen Overlay -->
    <div id="attract-screen">
        <div class="attract-content">
            <img id="attract-img" src="" alt="">
            <div class="attract-overlay"></div>
            <div class="attract-text">
                <h1>Touch to Start</h1>
                <p>PhotoBooth Pro</p>
            </div>
        </div>
    </div>

    <div id="flash-overlay"></div>

    <div id="notification-toast">
        <img id="toast-thumb" class="toast-thumb" alt="" />
        <svg id="toast-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
        <span id="notification-text">Saved to Device</span>
        <span id="toast-view-btn" class="toast-action">View</span>
        <span id="toast-undo-btn" class="toast-undo" style="display:none;">UNDO</span>
    </div>

    <!-- Login View -->
    <div id="login-view" class="view">
        <div class="login-container initial-slide" id="login-card">
            <div class="login-logo">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="url(#grad1)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#4a90e2;stop-opacity:1" /><stop offset="100%" style="stop-color:#9b59b6;stop-opacity:1" /></linearGradient></defs>
                    <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>
                </svg>
            </div>
            <h1 class="login-title">PhotoBooth Pro</h1>
            <div class="input-group">
                <input type="password" id="login-password" placeholder="Enter Passcode" />
                <button id="login-btn" class="btn-primary">Unlock</button>
            </div>
            <div id="login-error" class="login-error">Incorrect Passcode</div>
        </div>
    </div>

    <div id="welcome-overlay">
        <div class="welcome-content">
            <div id="welcome-icon">ðŸ‘‹</div>
            <h1 id="welcome-msg"></h1>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">Settings</div>
            
            <div class="modal-row" style="flex-direction:column; align-items:flex-start;">
                <div id="user-info-display" style="font-weight:bold; color:var(--brand-color); margin-bottom: 10px;">
                    Logged in as: Guest
                </div>

                <label style="margin-bottom:5px; color:#aaa; font-size:0.9em;">Camera Source</label>
                <select id="camera-select" style="width:100%;">
                    <option value="">Loading cameras...</option>
                </select>
            </div>
            
            <div class="modal-row" style="flex-direction:column; align-items:flex-start;">
                <label style="margin-bottom:5px; color:#aaa; font-size:0.9em;">Driver / Resolution Fix</label>
                <select id="driver-mode-select" style="width:100%;">
                    <option value="auto" selected>Auto (Smart Detect)</option>
                    <option value="sony">Sony / Green Line Fix (1024x576)</option>
                    <option value="hd">Standard HD (1280x720)</option>
                    <option value="vga">Safe Mode / VGA (640x480)</option>
                </select>
                <div style="font-size:0.8em; color:#666; margin-top:5px;">*Select 'Sony' if seeing green lines or logo only.</div>
            </div>

            <div class="modal-row" style="flex-direction:column; align-items:flex-start;">
                <label style="margin-bottom:5px; color:#aaa; font-size:0.9em;">Manual Photo Count</label>
                <select id="photo-count-select" style="width:100%;">
                    <option value="1"selected>1 Photo</option>
                    <option value="2">2 Photos</option>
                    <option value="3">3 Photos</option>
                    <option value="4">4 Photos</option>
                    <option value="5">5 Photos</option>
                    <option value="6">6 Photos</option>
                    <option value="8">8 Photos</option>
                </select>
            </div>

            <!-- NEW: Analytics Dashboard -->
            <div class="modal-header" style="margin-top:20px; border-top:1px solid #444; padding-top:10px;">Analytics</div>
            <div class="stats-grid" style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px;">
                <div class="stat-box" style="background:#111; padding:10px; border-radius:8px; text-align:center;">
                    <div id="stat-photos" style="font-size:1.5em; font-weight:bold; color:var(--brand-color);">0</div>
                    <div style="font-size:0.7em; color:#888;">Photos Taken</div>
                </div>
                <div class="stat-box" style="background:#111; padding:10px; border-radius:8px; text-align:center;">
                    <div id="stat-sessions" style="font-size:1.5em; font-weight:bold; color:#28a745;">0</div>
                    <div style="font-size:0.7em; color:#888;">Sessions</div>
                </div>
                <div class="stat-box" style="background:#111; padding:10px; border-radius:8px; text-align:center;">
                    <div id="stat-prints" style="font-size:1.5em; font-weight:bold; color:#ffc107;">0</div>
                    <div style="font-size:0.7em; color:#888;">Prints</div>
                </div>
                <div class="stat-box" style="background:#111; padding:10px; border-radius:8px; text-align:center;">
                     <div id="stat-storage" style="font-size:1.2em; font-weight:bold; color:#dc3545;">0 MB</div>
                    <div style="font-size:0.7em; color:#888;">Est. Storage</div>
                </div>
            </div>
            <button id="reset-stats-btn" class="btn" style="width:100%; background:#333; font-size:0.8em;">Reset Statistics</button>

            <div class="modal-footer">
                <button id="logout-btn" class="btn" style="background-color: transparent; border: 1px solid #dc3545; color: #dc3545; padding: 8px 15px; font-size: 0.9em;">Logout</button>
                <button id="close-settings-btn" class="btn" style="background-color:#4a90e2;">Done</button>
            </div>
        </div>
    </div>

    <!-- Layout Generator Modal -->
    <div id="layout-generator-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">Create Custom Layout</div>
            <div class="modal-row">
                <label>Rows:</label>
                <input type="number" id="lg-rows" value="2" min="1" max="5" style="width:60px;">
            </div>
            <div class="modal-row">
                <label>Columns:</label>
                <input type="number" id="lg-cols" value="2" min="1" max="4" style="width:60px;">
            </div>
            <div class="modal-row">
                <label>Padding (px):</label>
                <input type="number" id="lg-padding" value="50" min="0" max="200" style="width:60px;">
            </div>
            <div class="modal-row">
                <label>Gap (px):</label>
                <input type="number" id="lg-gap" value="20" min="0" max="100" style="width:60px;">
            </div>
            <div class="modal-row">
                <label>Background:</label>
                <input type="color" id="lg-color" value="#ffffff" style="width:60px; height:35px; padding:0; border:none;">
            </div>
            <div class="lg-preview">
                <img id="lg-canvas-preview" />
            </div>
            <div class="modal-footer">
                <button id="lg-cancel-btn" class="btn">Cancel</button>
                <button id="lg-create-btn" class="btn">Use Layout</button>
            </div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">Confirm Action</div>
            <p id="confirm-msg" style="text-align:center; margin: 10px 0;">Retake this photo?</p>
            <div class="modal-footer" style="justify-content:center;">
                <button id="confirm-yes" class="btn">Yes</button>
                <button id="confirm-no" class="btn">No</button>
            </div>
        </div>
    </div>

    <!-- Gallery Modal (Preview) -->
    <div id="gallery-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span>Gallery Preview</span>
                <button id="close-gallery-btn" class="control-btn-small" style="border:none;">âœ•</button>
            </div>
            <div id="gallery-list" class="gallery-grid">
                <div class="gallery-empty">No photos yet</div>
            </div>
            <div class="modal-footer">
                <button id="gallery-delete-all-btn" class="btn" style="background-color: transparent; border: 1px solid #dc3545; color: #dc3545;">Delete All</button>
                <button id="gallery-close-btn-footer" class="btn">Close</button>
            </div>
        </div>
    </div>

    <!-- View 1: Home Screen -->
    <div id="template-view" class="view">
        <button id="settings-btn" class="settings-btn" title="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.04,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.43-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.57,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.08-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
            </svg>
        </button>

        <div class="hero-section">
            <h1 class="hero-title">PhotoBooth Pro</h1>
            <div class="hero-subtitle">Capture. Edit. Share.</div>
        </div>

        <div class="cards-container">
            <div class="action-card">
                <div class="card-header">
                    <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
                    <h3 class="card-title">Quick Start</h3>
                </div>
                <div class="btn-grid">
                    <button id="qs-strip-btn" class="action-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="7" y="2" width="10" height="20" rx="2"></rect><line x1="7" y1="8" x2="17" y2="8"></line><line x1="7" y1="16" x2="17" y2="16"></line></svg>
                        Strip (3)
                    </button>
                    <button id="qs-grid-btn" class="action-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="12" x2="21" y2="12"></line><line x1="12" y1="3" x2="12" y2="21"></line></svg>
                        Grid (4)
                    </button>
                </div>
            </div>

            <div class="action-card">
                <div class="card-header">
                    <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"></path><polygon points="18 2 22 6 12 16 8 16 8 12 18 2"></polygon></svg>
                    <h3 class="card-title">Creative Studio</h3>
                </div>
                <div class="btn-grid">
                    <button id="open-layout-gen-btn" class="action-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle></svg>
                        Layout Gen
                    </button>
                    <label for="template-input" class="action-btn" style="margin:0;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                        Upload PNG
                    </label>
                </div>
                <input type="file" id="template-input" accept="image/png">
                <div id="file-name"></div>
                <div id="auto-map-msg"></div>
                <button id="start-btn" class="btn-primary" disabled style="display:none;">Start Session</button>
            </div>

            <div class="action-card">
                <div class="card-header">
                    <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle></svg>
                    <h3 class="card-title">Freestyle</h3>
                </div>
                <button id="start-no-template-btn" class="action-btn" style="width:100%;">Start without Template</button>
            </div>
        </div>
        
        <button id="gallery-btn" class="btn" style="margin-top:20px; width: auto; min-width: 200px;">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg> View Gallery
        </button>

        <div class="creator-credit">Created by DAVID JESS F. ASAURO</div>
        <div id="kb-shortcuts-overlay">Space:Capture | P:Print | S:Save | R:Retake</div>
    </div>

    <!-- View 1.5: Template Mapping -->
    <div id="mapping-view" class="view">
        <h2>ICT Photo Studio</h2>
        <div id="mapping-toolbar">
            <button class="tool-btn active" id="tool-rect" title="Rectangle Mode"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg></button>
            <button class="tool-btn" id="tool-circle" title="Circle Mode"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg></button>
            <div style="width:1px; background:#555; margin:0 5px;"></div>
            <button class="tool-btn active" id="tool-snap" title="Snap Guides">Snap</button>
            <button class="tool-btn" id="tool-ratio" title="Aspect Ratio: Free">Free</button>
        </div>
        <p class="mapping-text" id="mapping-instructions">Draw slots for photos.</p>
        <div id="mapping-container">
            <canvas id="mapping-canvas" tabindex="0"></canvas>
            <div id="magnifier"></div>
        </div>
        
        <div id="mapping-controls-panel" class="hidden">
            <div class="control-row">
                <span id="slot-info-label" class="info-pill">Slot #1</span>
                <span id="scale-value-label" class="info-pill">Scale: 100%</span>
                <button id="delete-slot-btn" class="tool-btn" style="background: #dc3545; border-color: #dc3545; padding: 2px 8px; font-size: 0.8em;">Delete</button>
            </div>
            <div class="control-row">
                <label style="font-size: 0.9em; color: #ddd;">Rotation:</label>
                <button class="tool-btn" id="rot-ccw" title="-90Â°">â†º</button>
                <input type="range" id="rotation-slider" min="-180" max="180" value="0" step="1">
                <button class="tool-btn" id="rot-cw" title="+90Â°">â†»</button>
                <span id="rotation-display" class="rot-display">0Â°</span>
            </div>
            <button id="confirm-adjustment-btn" class="btn-primary" style="width: 100%; padding: 8px; margin-top: 5px;">Done Editing</button>
        </div>

        <div class="button-group">
            <button id="change-template-btn" class="btn">Back</button> 
            <button id="reset-mapping-btn" class="btn">Reset</button>
            <button id="undo-btn" class="btn">Undo</button>
            <button id="start-mapped-btn" class="btn" style="display: none;">Start PhotoBooth</button>
        </div>
    </div>

    <!-- View 2: Camera (IMMERSIVE) -->
    <div id="camera-view" class="view" tabindex="0">
        <div id="camera-top-bar">
            <button id="close-camera-btn" class="icon-btn" title="Back to Layout">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            </button>
            <div style="display:flex; gap:10px;">
                 <button id="toggle-template-overlay-btn" class="icon-btn" title="Toggle Template Overlay">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                </button>
            </div>
        </div>
        <div id="video-container">
            <video id="video-preview" autoplay playsinline muted></video>
            <canvas id="ai-canvas" style="display:none;"></canvas>
            <div id="grid-overlay">
                <div class="grid-line grid-h" style="top: 33.33%;"></div>
                <div class="grid-line grid-h" style="top: 66.66%;"></div>
                <div class="grid-line grid-v" style="left: 33.33%;"></div>
                <div class="grid-line grid-v" style="left: 66.66%;"></div>
            </div>
            <img id="live-template-img" src="" alt="Template Overlay">
            <div id="crop-frame-overlay"></div>
            <img id="photo-preview-overlay" /> 
            <div id="photo-counter-overlay">0 / 4</div>
            <div id="countdown-overlay"></div>
        </div>
        <div id="camera-bottom-bar">
            <div id="camera-controls">
                <select id="timer-select" title="Countdown Timer">
                    <option value="3">3s Timer</option>
                    <option value="5" selected>5s Timer</option>
                    <option value="10">10s Timer</option>
                </select>
                <select id="filter-select" title="Photo Filter">
                    <option value="none" selected>Normal</option>
                    <option value="grayscale(100%)">B&W</option>
                    <option value="sepia(100%)">Sepia</option>
                    <option value="invert(100%)">Negative</option>
                    <option value="sepia(0.4) contrast(1.2) brightness(0.9)">Vintage</option>
                    <option value="saturate(2.0) hue-rotate(10deg) contrast(1.1)">Cyberpunk</option>
                    <option value="grayscale(1) contrast(1.5) brightness(0.9)">Dramatic</option>
                </select>
                
                <button id="toggle-flash-btn" class="control-btn-small" title="Toggle Screen Flash">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
                </button>

                <button id="toggle-ai-blur-btn" class="control-btn-small" title="AI Portrait Mode"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg></button>
                <button id="toggle-grid-btn" class="control-btn-small" title="Rule of Thirds Grid"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line></svg></button>
                
                <div id="zoom-container">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
                    <input type="range" id="zoom-slider" min="1" max="3" step="0.1" value="1" title="Zoom">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
                </div>
                <label class="toggle-label"><input type="checkbox" id="mirror-toggle"> Mirror</label>
            </div>
            <button id="capture-btn" title="Press Spacebar"></button>
        </div>

        <div id="captured-thumbnails"></div>
    </div>

    <!-- View 3: Preview & Edit -->
    <div id="preview-view" class="view">
        <h2>Make it Yours</h2>
        <div class="hint-text">Tip: Tap a photo to retake it specifically!</div>
        <div id="preview-container">
            <canvas id="merge-canvas"></canvas>
        </div>
        <div class="button-group">
            <button id="remap-btn" class="btn" style="display: none;">Remap</button> 
            <button id="print-btn" class="btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></svg> Print
            </button>
            <button id="save-btn" class="btn"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg> Download</button>
            
            <!-- CHANGED: Renamed from "Retake All" to "Retake Session" -->
            <button id="retake-btn" class="btn">Retake Session</button>
            
            <button id="home-btn" class="btn" style="background-color: #6c757d;">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg> New Session
            </button>

            <button id="close-preview-btn" class="btn" style="background-color: #6c757d; display: none;">Close</button>
        </div>
    </div>

    <canvas id="capture-canvas" style="display: none;"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const APP_VERSION = '1.3'; 

            const AudioContext = window.AudioContext || window.webkitAudioContext;
            let audioCtx = new AudioContext();

            // Stats Variables
            let stats = { photos: 0, sessions: 0, prints: 0 };
            
            function loadStats() {
                const s = localStorage.getItem('pb_stats');
                if (s) stats = JSON.parse(s);
            }
            function saveStats() {
                localStorage.setItem('pb_stats', JSON.stringify(stats));
                updateStatsUI();
            }
            function updateStatsUI() {
                if(document.getElementById('stat-photos')) {
                    document.getElementById('stat-photos').textContent = stats.photos;
                    document.getElementById('stat-sessions').textContent = stats.sessions;
                    document.getElementById('stat-prints').textContent = stats.prints;
                    const estSize = ((stats.photos * 0.3) + (stats.sessions * 0.5)).toFixed(1);
                    document.getElementById('stat-storage').textContent = estSize + ' MB';
                }
            }
            loadStats(); // Load stats on startup

            // Attract Mode Variables
            let idleTimeout;
            let attractImageInterval;
            const IDLE_LIMIT = 60000; // 60 seconds

            function resetIdleTimer() {
                clearTimeout(idleTimeout);
                if (document.getElementById('attract-screen').style.display === 'flex') {
                    stopAttractMode();
                }
                // Only start timer if logged in
                if (sessionStorage.getItem('pb_auth_user')) {
                    idleTimeout = setTimeout(startAttractMode, IDLE_LIMIT);
                }
            }

            function startAttractMode() {
                // Don't start if currently in camera view or preview
                const inCamera = document.getElementById('camera-view').style.display === 'flex';
                const inPreview = document.getElementById('preview-view').style.display === 'flex';
                // Only activate if we are essentially "waiting" (e.g. Home screen) or just abandonned
                // Actually, let's allow it everywhere but reset if active
                
                const attractEl = document.getElementById('attract-screen');
                if (attractEl.style.display === 'flex') return;
                
                attractEl.style.display = 'flex';
                cycleAttractImages();
                attractImageInterval = setInterval(cycleAttractImages, 4000);
            }

            function stopAttractMode() {
                const attractEl = document.getElementById('attract-screen');
                attractEl.style.display = 'none';
                clearInterval(attractImageInterval);
            }

            function cycleAttractImages() {
                const gallery = JSON.parse(localStorage.getItem('pb_gallery') || '[]');
                const imgEl = document.getElementById('attract-img');
                
                if (gallery.length > 0) {
                    const rand = gallery[Math.floor(Math.random() * gallery.length)];
                    imgEl.style.opacity = 0;
                    setTimeout(() => {
                        imgEl.src = rand;
                        imgEl.style.opacity = 0.6; 
                    }, 500); // Wait for fade out
                } else {
                    // Fallback if empty gallery
                    imgEl.src = "";
                    imgEl.style.opacity = 0;
                }
            }

            // Attract Mode Events
            ['mousemove', 'mousedown', 'touchstart', 'keypress'].forEach(evt => {
                document.addEventListener(evt, resetIdleTimer);
            });
            

            function playBeep() {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.type = 'square'; osc.frequency.value = 660; 
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                osc.start(); osc.stop(audioCtx.currentTime + 0.15);
            }

            function playShutter() {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const t = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.type = 'square'; osc.frequency.setValueAtTime(1318.5, t); 
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.setValueAtTime(0.2, t + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
                osc.start(t); osc.stop(t + 0.8);
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();
                osc2.connect(gain2); gain2.connect(audioCtx.destination);
                osc2.type = 'sawtooth'; osc2.frequency.setValueAtTime(1325, t); 
                gain2.gain.setValueAtTime(0.05, t);
                gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                osc2.start(t); osc2.stop(t + 0.4);
            }
            
            function playSuccessSound() {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const t = audioCtx.currentTime;
                const notes = [523.25, 659.25, 783.99]; 
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); gain.connect(audioCtx.destination);
                    osc.type = 'sine'; osc.frequency.value = freq;
                    const startTime = t + (i * 0.05); 
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.1, startTime + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);
                    osc.start(startTime); osc.stop(startTime + 0.4);
                });
            }

            function playKeyClick() {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const t = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.type = 'sine'; 
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(40, t + 0.03);
                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
                osc.start(t); osc.stop(t + 0.04);
            }

            function playStartupSound() {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const t = audioCtx.currentTime;
                const notes = [261.63, 329.63, 392.00, 523.25];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain); gain.connect(audioCtx.destination);
                    osc.type = 'triangle'; 
                    osc.frequency.value = freq;
                    const startTime = t + (i * 0.1); 
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.1, startTime + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.6);
                    osc.start(startTime);
                    osc.stop(startTime + 0.6);
                });
            }

            const views = {
                login: document.getElementById('login-view'),
                template: document.getElementById('template-view'),
                mapping: document.getElementById('mapping-view'), 
                camera: document.getElementById('camera-view'),
                preview: document.getElementById('preview-view')
            };
            
            const templateInput = document.getElementById('template-input');
            const fileNameEl = document.getElementById('file-name');
            const autoMapMsg = document.getElementById('auto-map-msg');
            const startBtn = document.getElementById('start-btn');
            const startNoTemplateBtn = document.getElementById('start-no-template-btn');
            const cameraSelect = document.getElementById('camera-select'); 
            const photoCountSelect = document.getElementById('photo-count-select'); 
            const qsStripBtn = document.getElementById('qs-strip-btn');
            const qsGridBtn = document.getElementById('qs-grid-btn');

            const loginCard = document.getElementById('login-card');
            const loginPassInput = document.getElementById('login-password');
            const loginBtn = document.getElementById('login-btn');
            const loginError = document.getElementById('login-error');
            const welcomeOverlay = document.getElementById('welcome-overlay');
            const welcomeMsg = document.getElementById('welcome-msg');
            const logoutBtn = document.getElementById('logout-btn');
            const userInfoDisplay = document.getElementById('user-info-display');

            const settingsModal = document.getElementById('settings-modal');
            const settingsBtn = document.getElementById('settings-btn');
            const closeSettingsBtn = document.getElementById('close-settings-btn');
            const driverModeSelect = document.getElementById('driver-mode-select');
            
            // Stats Elements
            const resetStatsBtn = document.getElementById('reset-stats-btn');

            const lgModal = document.getElementById('layout-generator-modal');
            const openLgBtn = document.getElementById('open-layout-gen-btn');
            const lgCancelBtn = document.getElementById('lg-cancel-btn');
            const lgCreateBtn = document.getElementById('lg-create-btn');
            const lgPreview = document.getElementById('lg-canvas-preview');
            const lgInputs = {
                rows: document.getElementById('lg-rows'),
                cols: document.getElementById('lg-cols'),
                padding: document.getElementById('lg-padding'),
                gap: document.getElementById('lg-gap'),
                color: document.getElementById('lg-color')
            };

            const mappingCanvas = document.getElementById('mapping-canvas');
            const mappingCtx = mappingCanvas.getContext('2d');
            const magnifier = document.getElementById('magnifier');
            const mappingInstructions = document.getElementById('mapping-instructions');
            const resetMappingBtn = document.getElementById('reset-mapping-btn');
            const changeTemplateBtn = document.getElementById('change-template-btn'); 
            const startMappedBtn = document.getElementById('start-mapped-btn');
            const undoBtn = document.getElementById('undo-btn');
            
            const deleteSlotBtn = document.getElementById('delete-slot-btn');
            const mappingControlsPanel = document.getElementById('mapping-controls-panel');
            const slotInfoLabel = document.getElementById('slot-info-label');
            const scaleValueLabel = document.getElementById('scale-value-label');
            const rotationSlider = document.getElementById('rotation-slider');
            const rotationDisplay = document.getElementById('rotation-display');
            const rotCCW = document.getElementById('rot-ccw');
            const rotCW = document.getElementById('rot-cw');
            const confirmAdjustmentBtn = document.getElementById('confirm-adjustment-btn');
            
            const toolRect = document.getElementById('tool-rect');
            const toolCircle = document.getElementById('tool-circle');
            const toolSnap = document.getElementById('tool-snap');
            const toolRatio = document.getElementById('tool-ratio');

            const cameraView = document.getElementById('camera-view'); 
            const cameraControls = document.getElementById('camera-controls');
            const videoEl = document.getElementById('video-preview');
            const aiCanvas = document.getElementById('ai-canvas');
            const aiCtx = aiCanvas.getContext('2d');
            const liveTemplateImg = document.getElementById('live-template-img');
            const cropFrameOverlay = document.getElementById('crop-frame-overlay'); 
            const captureBtn = document.getElementById('capture-btn');
            const photoCounterEl = document.getElementById('photo-counter-overlay');
            const countdownEl = document.getElementById('countdown-overlay');
            const closeCameraBtn = document.getElementById('close-camera-btn'); 
            const filterSelect = document.getElementById('filter-select');
            const timerSelect = document.getElementById('timer-select');
            const mirrorToggle = document.getElementById('mirror-toggle');
            const toggleAiBlurBtn = document.getElementById('toggle-ai-blur-btn');
            const toggleFlashBtn = document.getElementById('toggle-flash-btn');

            const toggleOverlayBtn = document.getElementById('toggle-template-overlay-btn');
            const toggleGridBtn = document.getElementById('toggle-grid-btn');
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomContainer = document.getElementById('zoom-container');
            const gridOverlay = document.getElementById('grid-overlay');

            const mergeCanvas = document.getElementById('merge-canvas');
            const mergeCtx = mergeCanvas.getContext('2d');
            const retakeBtn = document.getElementById('retake-btn');
            const saveBtn = document.getElementById('save-btn');
            const remapBtn = document.getElementById('remap-btn'); 
            const printBtn = document.getElementById('print-btn');
            const homeBtn = document.getElementById('home-btn');
            const closePreviewBtn = document.getElementById('close-preview-btn');

            const galleryBtn = document.getElementById('gallery-btn');
            const galleryModal = document.getElementById('gallery-modal');
            const closeGalleryBtn = document.getElementById('close-gallery-btn');
            const galleryCloseBtnFooter = document.getElementById('gallery-close-btn-footer');
            const galleryList = document.getElementById('gallery-list');
            const galleryDeleteAllBtn = document.getElementById('gallery-delete-all-btn');

            const capturedThumbnailsEl = document.getElementById('captured-thumbnails');
            const captureCanvas = document.getElementById('capture-canvas');
            const captureCtx = captureCanvas.getContext('2d');
            const flashOverlay = document.getElementById('flash-overlay');
            
            const notificationToast = document.getElementById('notification-toast');
            const notificationText = document.getElementById('notification-text');
            const toastThumb = document.getElementById('toast-thumb');
            const toastIcon = document.getElementById('toast-icon');
            const toastViewBtn = document.getElementById('toast-view-btn');
            const toastUndoBtn = document.getElementById('toast-undo-btn');

            const confirmModal = document.getElementById('confirm-modal');
            const confirmMsg = document.getElementById('confirm-msg');
            const confirmYes = document.getElementById('confirm-yes');
            const confirmNo = document.getElementById('confirm-no');
            
            let onConfirmAction = null; 

            // Undo State
            let lastDeletedPhoto = null;
            let lastDeletedIndex = -1;

            let stream = null;
            let videoTrack = null;
            let templateImage = new Image();
            let templateImageData = null; 
            let useTemplate = false;
            let capturedPhotos = []; 
            let photoCount = 0;
            let countdownInterval = null;
            let retakeIndex = null; 
            const TARGET_ASPECT_RATIO = 16 / 9; 
            
            // CHANGED: Default to 1 photo (was 4)
            let numPhotosToTake = 1; 
            
            let templateOverlayEnabled = false;
            let aiBlurEnabled = false;
            let flashEnabled = false; 
            
            let selfieSegmentation = null;
            let animationFrameId = null;
            let isCountingDown = false;
            let isQuickStart = false; 
            let gestureDebounce = 0;
            
            let lastUsedDriverMode = null; 
            let photoSlots = []; 
            let detectedHoles = []; 
            let undoStack = []; 
            let returnToGallery = false; 
            let mappingState = { 
                selectedIndex: -1, drawingShape: 'rect', aspectRatio: null, snapEnabled: true,
                isCreating: false, startX: 0, startY: 0, tempX: 0, tempY: 0,
                isDragging: false, dragType: null, dragOffsetX: 0, dragOffsetY: 0,
                initialPinchDist: null, initialPinchAngle: null, baseWidth: 0, baseHeight: 0, baseCenterX: 0, baseCenterY: 0
            };
            
            function loadState() {
                try {
                    const savedVersion = localStorage.getItem('pb_version');
                    if (savedVersion !== APP_VERSION) {
                        localStorage.removeItem('pb_template');
                        localStorage.removeItem('pb_slots');
                        localStorage.removeItem('pb_count');
                        localStorage.setItem('pb_version', APP_VERSION); 
                        renderGallery(); 
                        return; 
                    }

                    const savedTemplate = localStorage.getItem('pb_template');
                    const savedSlots = localStorage.getItem('pb_slots');
                    const savedCount = localStorage.getItem('pb_count');
                    
                    if (savedTemplate && savedSlots) {
                        const img = new Image();
                        img.onload = () => {
                            templateImage = img;
                            updateTemplateImageData(img);
                            analyzeTemplateHoles(); 
                            photoSlots = JSON.parse(savedSlots);
                            // CHANGED: Fallback to 1 if parsing fails
                            numPhotosToTake = parseInt(savedCount) || 1;
                            photoCountSelect.value = numPhotosToTake;
                            fileNameEl.textContent = "Restored previous session.";
                            startBtn.style.display = 'block';
                            startBtn.disabled = false;
                        };
                        img.src = savedTemplate;
                    }
                    renderGallery();
                } catch (e) { console.log("Storage load failed", e); }
            }
            loadState(); 

            function saveState() {
                try {
                    if (templateImage.src.startsWith('data:')) {
                        localStorage.setItem('pb_template', templateImage.src);
                        localStorage.setItem('pb_slots', JSON.stringify(photoSlots));
                        localStorage.setItem('pb_count', numPhotosToTake);
                        localStorage.setItem('pb_version', APP_VERSION); 
                    }
                } catch (e) { console.log("Storage save error", e); }
            }
            
            function deleteFromGallery(index) {
                try {
                    let gallery = JSON.parse(localStorage.getItem('pb_gallery') || '[]');
                    lastDeletedPhoto = gallery[index];
                    lastDeletedIndex = index;
                    gallery.splice(index, 1);
                    localStorage.setItem('pb_gallery', JSON.stringify(gallery));
                    renderGallery();
                    showNotification("Photo Deleted", null, 'undo'); 
                } catch (e) {
                    console.error("Delete failed", e);
                }
            }

            function undoLastDelete() {
                if (!lastDeletedPhoto || lastDeletedIndex === -1) return;
                try {
                    let gallery = JSON.parse(localStorage.getItem('pb_gallery') || '[]');
                    gallery.splice(lastDeletedIndex, 0, lastDeletedPhoto);
                    localStorage.setItem('pb_gallery', JSON.stringify(gallery));
                    renderGallery();
                    lastDeletedPhoto = null;
                    lastDeletedIndex = -1;
                    showNotification("Photo Restored");
                } catch(e) { console.error("Undo failed", e); }
            }

            galleryDeleteAllBtn.addEventListener('click', () => {
                confirmMsg.textContent = "Delete ALL photos? This cannot be undone.";
                confirmModal.style.display = 'flex';
                onConfirmAction = () => {
                    localStorage.removeItem('pb_gallery');
                    renderGallery();
                    showNotification("Gallery Cleared", null, true);
                };
            });

            function saveToGallery(dataUrl) {
                let gallery = [];
                try {
                    gallery = JSON.parse(localStorage.getItem('pb_gallery') || '[]');
                } catch (e) { gallery = []; }

                gallery.unshift(dataUrl);
                if (gallery.length > 15) gallery.length = 15;

                let saved = false;
                while (!saved && gallery.length > 0) {
                    try {
                        localStorage.setItem('pb_gallery', JSON.stringify(gallery));
                        saved = true;
                    } catch (e) {
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            if (gallery.length > 1) {
                                gallery.pop(); 
                            } else {
                                showNotification("Gallery Full", null, true); 
                                break; 
                            }
                        } else {
                            break;
                        }
                    }
                }
                renderGallery();
            }
            
            function renderGallery() {
                let gallery = [];
                try {
                     gallery = JSON.parse(localStorage.getItem('pb_gallery') || '[]');
                } catch(e) { return; }

                galleryList.innerHTML = '';
                if(gallery.length === 0) {
                    galleryList.innerHTML = '<div class="gallery-empty">No photos saved yet.</div>';
                    galleryDeleteAllBtn.style.display = 'none'; 
                    return;
                } else {
                    galleryDeleteAllBtn.style.display = 'block';
                }
                
                gallery.forEach((imgSrc, index) => {
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    
                    const img = document.createElement('img');
                    img.src = imgSrc;
                    
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'gallery-delete-btn';
                    deleteBtn.innerHTML = 'Ã—'; 
                    deleteBtn.title = 'Delete Photo';
                    
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation(); 
                        confirmMsg.textContent = "Delete this photo permanently?";
                        confirmModal.style.display = 'flex';
                        onConfirmAction = () => {
                            item.classList.add('deleting');
                            setTimeout(() => {
                                deleteFromGallery(index);
                            }, 400); 
                        };
                    };

                    item.appendChild(img);
                    item.appendChild(deleteBtn);

                    item.onclick = () => {
                        const previewImg = new Image();
                        previewImg.onload = () => {
                            mergeCanvas.width = previewImg.width;
                            mergeCanvas.height = previewImg.height;
                            mergeCtx.drawImage(previewImg, 0, 0);
                            showView('preview');
                            remapBtn.style.display = 'none'; 
                            galleryModal.style.display = 'none';
                            retakeBtn.style.display = 'none'; 
                            homeBtn.style.display = 'none'; 
                            closePreviewBtn.style.display = 'inline-flex'; 
                            returnToGallery = true; 
                        };
                        previewImg.src = imgSrc;
                    };
                    galleryList.appendChild(item);
                });
            }

            function updateTemplateImageData(img) {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                ctx.drawImage(img, 0, 0);
                templateImageData = ctx.getImageData(0, 0, img.width, img.height);
            }

            async function initMediaPipe() {
                if (!selfieSegmentation) {
                    selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`});
                    selfieSegmentation.setOptions({ modelSelection: 1 }); 
                    selfieSegmentation.onResults(onSelfieResults);
                }
            }

            function onSelfieResults(results) {
                if (!aiBlurEnabled) return;
                aiCanvas.width = videoEl.videoWidth; aiCanvas.height = videoEl.videoHeight;
                aiCtx.save(); aiCtx.clearRect(0, 0, aiCanvas.width, aiCanvas.height);
                aiCtx.drawImage(results.segmentationMask, 0, 0, aiCanvas.width, aiCanvas.height);
                aiCtx.globalCompositeOperation = 'source-in'; aiCtx.drawImage(results.image, 0, 0, aiCanvas.width, aiCanvas.height);
                aiCtx.globalCompositeOperation = 'destination-over'; aiCtx.filter = 'blur(10px)'; aiCtx.drawImage(results.image, 0, 0, aiCanvas.width, aiCanvas.height);
                aiCtx.restore();
            }

            async function startVideoProcessing() {
                if (!videoEl.srcObject) return;
                async function step() { 
                    if (!stream) return;
                    if (aiBlurEnabled) await selfieSegmentation.send({image: videoEl}); 
                    animationFrameId = requestAnimationFrame(step); 
                }
                await initMediaPipe(); step();
            }

            toggleAiBlurBtn.addEventListener('click', () => {
                aiBlurEnabled = !aiBlurEnabled; toggleAiBlurBtn.classList.toggle('active');
                videoEl.style.opacity = aiBlurEnabled ? 0 : 1; aiCanvas.style.display = aiBlurEnabled ? 'block' : 'none';
                if(mirrorToggle.checked) aiCanvas.classList.add('mirrored');
                if (aiBlurEnabled) startVideoProcessing();
            });

            toggleFlashBtn.addEventListener('click', () => {
                flashEnabled = !flashEnabled;
                toggleFlashBtn.classList.toggle('active');
            });

            toggleGridBtn.addEventListener('click', () => {
                const isActive = gridOverlay.style.display === 'block';
                gridOverlay.style.display = isActive ? 'none' : 'block';
                toggleGridBtn.classList.toggle('active', !isActive);
            });

            mirrorToggle.addEventListener('change', () => {
                if(mirrorToggle.checked) { 
                    videoEl.classList.add('mirrored'); 
                    aiCanvas.classList.add('mirrored'); 
                } else { 
                    videoEl.classList.remove('mirrored'); 
                    aiCanvas.classList.remove('mirrored'); 
                }
            });

            function getGreeting() {
                const h = new Date().getHours();
                if (h < 12) return "Good Morning";
                if (h < 18) return "Good Afternoon";
                return "Good Evening";
            }

            function handleLogin() {
                const pass = loginPassInput.value.trim();
                const encodedPass = btoa(pass); 
                let user = "";

                if (encodedPass === 'anJuZXN0LjIwMjU=') {
                    user = "Master Jrnest";
                } else if (encodedPass === 'MDkyMDg4OTQzMDUyNDc=') {
                    user = "Master Dave";
                } else {
                    loginCard.classList.add('error-shake');
                    loginError.style.opacity = 1;
                    setTimeout(() => {
                        loginCard.classList.remove('error-shake');
                        loginError.style.opacity = 0;
                    }, 2000);
                    return;
                }

                sessionStorage.setItem('pb_auth_user', user);
                updateUserDisplay();
                resetIdleTimer(); // Start tracking for attract mode
                
                playStartupSound();

                loginPassInput.value = "";
                
                const phrases = [
                    "Time to shine,",
                    "Let's make magic,",
                    "Camera ready,",
                    "Looking good,",
                    "Welcome back,"
                ];
                const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
                
                welcomeMsg.innerHTML = '<span id="type-text" class="typing-cursor"></span><br><span id="name-text"></span>';
                welcomeOverlay.style.display = "flex";
                
                const typeEl = document.getElementById('type-text');
                const nameEl = document.getElementById('name-text');
                
                let i = 0;
                function typeWriter() {
                    if (i < randomPhrase.length) {
                        typeEl.textContent += randomPhrase.charAt(i);
                        i++;
                        setTimeout(typeWriter, 50); 
                    } else {
                        typeEl.classList.remove('typing-cursor');
                        nameEl.innerHTML = user;
                        nameEl.className = 'name-pop';
                        setTimeout(triggerCurtainReveal, 1000);
                    }
                }
                setTimeout(typeWriter, 300);

                function triggerCurtainReveal() {
                    showView('template'); 
                    requestAnimationFrame(() => {
                        welcomeOverlay.style.transform = "translateY(-100%)";
                    });

                    setTimeout(() => {
                        welcomeOverlay.style.display = "none";
                        welcomeOverlay.style.transform = ""; 
                    }, 800); 
                }
            }

            function updateUserDisplay() {
                if (!userInfoDisplay) return; 
                const user = sessionStorage.getItem('pb_auth_user') || "Guest";
                userInfoDisplay.textContent = `Logged in as: ${user}`;
            }

            function checkSession() {
                const user = sessionStorage.getItem('pb_auth_user');
                if (user) {
                    updateUserDisplay();
                    showView('template');
                    resetIdleTimer(); 
                } else {
                    showView('login');
                }
            }

            function performLogout() {
                document.body.classList.add('powering-down');
                setTimeout(() => {
                    sessionStorage.removeItem('pb_auth_user');
                    capturedPhotos = [];
                    photoCount = 0;
                    photoSlots = [];
                    templateImage.src = "";
                    fileNameEl.textContent = "";
                    startBtn.style.display = 'none';
                    settingsModal.style.display = 'none';
                    document.body.classList.remove('powering-down'); 
                    showView('login');
                    clearTimeout(idleTimeout); // Stop attract mode timer
                }, 600); 
            }

            loginBtn.addEventListener('click', handleLogin);
            loginPassInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleLogin();
            });
            loginPassInput.addEventListener('input', playKeyClick);

            if (logoutBtn) {
                logoutBtn.addEventListener('click', () => {
                    confirmMsg.textContent = "Are you sure you want to logout?";
                    confirmModal.style.display = 'flex';
                    onConfirmAction = () => {
                        performLogout();
                    };
                });
            }

            // Stats Logic Hooked into Reset Button
            resetStatsBtn.addEventListener('click', () => {
                confirmMsg.textContent = "Reset all statistics? This cannot be undone.";
                confirmModal.style.display = 'flex';
                onConfirmAction = () => {
                    stats = { photos: 0, sessions: 0, prints: 0 };
                    saveStats();
                    showNotification("Stats Reset");
                };
            });

            settingsBtn.addEventListener('click', () => { 
                updateStatsUI(); // Update UI when opening
                settingsModal.style.display = 'flex'; 
            });
            
            closeSettingsBtn.addEventListener('click', () => {
                settingsModal.style.display = 'none';
                if (views.camera.style.display === 'flex') {
                    startCamera();
                }
            });
            
            galleryBtn.addEventListener('click', () => galleryModal.style.display = 'flex');
            closeGalleryBtn.addEventListener('click', () => galleryModal.style.display = 'none');
            galleryCloseBtnFooter.addEventListener('click', () => galleryModal.style.display = 'none');
            
            openLgBtn.addEventListener('click', () => { lgModal.style.display = 'flex'; updateLgPreview(); });
            lgCancelBtn.addEventListener('click', () => lgModal.style.display = 'none');
            Object.values(lgInputs).forEach(input => input.addEventListener('input', updateLgPreview));

            function updateLgPreview() {
                const rows = parseInt(lgInputs.rows.value); const cols = parseInt(lgInputs.cols.value);
                const padding = parseInt(lgInputs.padding.value); const gap = parseInt(lgInputs.gap.value);
                const photoW = 600; const photoH = 400; 
                const totalW = (cols * photoW) + (padding * 2) + ((cols - 1) * gap);
                const totalH = (rows * photoH) + (padding * 2) + ((rows - 1) * gap);
                const cvs = document.createElement('canvas'); cvs.width = totalW; cvs.height = totalH;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = lgInputs.color.value; ctx.fillRect(0, 0, totalW, totalH);
                for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { ctx.clearRect(padding + c * (photoW + gap), padding + r * (photoH + gap), photoW, photoH); } }
                lgPreview.src = cvs.toDataURL();
            }

            lgCreateBtn.addEventListener('click', () => {
                templateImage.src = lgPreview.src; useTemplate = true;
                const rows = parseInt(lgInputs.rows.value); const cols = parseInt(lgInputs.cols.value);
                numPhotosToTake = rows * cols; photoCountSelect.value = numPhotosToTake;
                templateImage.onload = () => {
                    fileNameEl.textContent = "Custom Layout Generated"; updateTemplateImageData(templateImage);
                    analyzeTemplateHoles(); 
                    const padding = parseInt(lgInputs.padding.value); const gap = parseInt(lgInputs.gap.value); const photoW = 600; const photoH = 400;
                    photoSlots = [];
                    for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { photoSlots.push({ centerX: padding + c * (photoW + gap) + photoW/2, centerY: padding + r * (photoH + gap) + photoH/2, width: photoW + 10, height: photoH + 2, rotation: 0, scale: 1, shape: 'rect' }); } }
                    autoMapMsg.textContent = `âœ¨ Generated ${numPhotosToTake} slot layout!`; autoMapMsg.style.display = 'block';
                    startBtn.style.display = 'block'; startBtn.disabled = false; lgModal.style.display = 'none'; saveState();
                };
            });

            function analyzeTemplateHoles() {
                if (!templateImageData) return;
                const data = templateImageData.data; const w = templateImageData.width; const h = templateImageData.height;
                const visited = new Uint8Array(w * h); 
                detectedHoles = []; 
                const isTransparent = (i) => data[i * 4 + 3] < 50; 
                const rawRegions = [];
                for (let y = 0; y < h; y += 4) { 
                    for (let x = 0; x < w; x += 4) {
                        const i = y * w + x; 
                        if (visited[i] || !isTransparent(i)) continue;
                        const region = performFloodFillMoments(x, y, w, h, data, visited);
                        if (region.count > 100) { rawRegions.push(region); }
                    }
                }
                if (rawRegions.length > 0) {
                    rawRegions.sort((a, b) => b.count - a.count);
                    const maxArea = rawRegions[0].count;
                    detectedHoles = rawRegions.filter(r => r.count > (maxArea * 0.15));
                }
                console.log(`Analyzed template: Found ${detectedHoles.length} valid slots.`);
            }

            function detectTemplateSlots(img) {
                updateTemplateImageData(img); 
                analyzeTemplateHoles(); 
                const detected = [...detectedHoles];
                detected.sort((a, b) => { const rowThreshold = img.height * 0.1; if (Math.abs(a.centerY - b.centerY) < rowThreshold) return a.centerX - b.centerX; return a.centerY - b.centerY; });
                return detected.map(r => ({ centerX: r.centerX, centerY: r.centerY, width: r.width + 10, height: r.height + 2, rotation: r.rotation, scale: 1, shape: 'rect' }));
            }

            function performFloodFillMoments(startX, startY, w, h, data, visited) {
                const stack = [startX, startY]; 
                let sumX = 0, sumY = 0, sumXX = 0, sumYY = 0, sumXY = 0, count = 0; 
                const perimeterPoints = []; 
                while (stack.length) {
                    const y = stack.pop(); 
                    const x = stack.pop(); 
                    const i = y * w + x; 
                    if (visited[i]) continue; 
                    visited[i] = 1;
                    sumX += x; sumY += y; 
                    sumXX += x * x; sumYY += y * y; sumXY += x * y; 
                    count++; 
                    let isEdge = false;
                    if (x+1 >= w || data[(y*w+(x+1))*4+3] >= 50) isEdge = true;
                    else if (x-1 < 0 || data[(y*w+(x-1))*4+3] >= 50) isEdge = true;
                    else if (y+1 >= h || data[((y+1)*w+x)*4+3] >= 50) isEdge = true;
                    else if (y-1 < 0 || data[((y-1)*w+x)*4+3] >= 50) isEdge = true;
                    if (isEdge) { perimeterPoints.push({x, y}); }
                    if (x+1 < w && !visited[y*w+(x+1)] && data[(y*w+(x+1))*4+3] < 50) stack.push(x+1, y);
                    if (x-1 >= 0 && !visited[y*w+(x-1)] && data[(y*w+(x-1))*4+3] < 50) stack.push(x-1, y);
                    if (y+1 < h && !visited[(y+1)*w+x] && data[((y+1)*w+x)*4+3] < 50) stack.push(x, y+1);
                    if (y-1 >= 0 && !visited[(y-1)*w+x] && data[((y-1)*w+x)*4+3] < 50) stack.push(x, y-1);
                }
                const comX = sumX / count; 
                const comY = sumY / count;
                const u20 = sumXX / count - comX * comX; 
                const u02 = sumYY / count - comY * comY; 
                const u11 = sumXY / count - comX * comY;
                let initialTheta = 0.5 * Math.atan2(2 * u11, u20 - u02);
                let bestTheta = initialTheta;
                let bestArea = Infinity;
                let bestBounds = { minU: 0, maxU: 0, minV: 0, maxV: 0 };
                const anglesToCheck = [0, Math.PI/2];
                for (let i = -10; i <= 10; i+=1) { anglesToCheck.push(initialTheta + (i * Math.PI / 180)); }
                const pointsToCheck = perimeterPoints.length > 0 ? perimeterPoints : [{x: comX, y: comY}];
                for (let theta of anglesToCheck) {
                    let minU = Infinity, maxU = -Infinity; 
                    let minV = Infinity, maxV = -Infinity; 
                    const cos = Math.cos(-theta); 
                    const sin = Math.sin(-theta);
                    for (let p of pointsToCheck) { 
                        const dx = p.x - comX; 
                        const dy = p.y - comY; 
                        const u = dx * cos - dy * sin; 
                        const v = dx * sin + dy * cos; 
                        if (u < minU) minU = u; 
                        if (u > maxU) maxU = u; 
                        if (v < minV) minV = v; 
                        if (v > maxV) maxV = v; 
                    }
                    const w = maxU - minU;
                    const h = maxV - minV;
                    const area = w * h;
                    if (area < bestArea) {
                        bestArea = area;
                        bestTheta = theta;
                        bestBounds = { minU, maxU, minV, maxV };
                    }
                }
                const snapThreshold = 1.5 * Math.PI / 180; 
                if (Math.abs(bestTheta) < snapThreshold) bestTheta = 0;
                else if (Math.abs(Math.abs(bestTheta) - Math.PI/2) < snapThreshold) bestTheta = Math.sign(bestTheta) * Math.PI/2;
                const width = bestBounds.maxU - bestBounds.minU;
                const height = bestBounds.maxV - bestBounds.minV;
                const midU = (bestBounds.minU + bestBounds.maxU) / 2;
                const midV = (bestBounds.minV + bestBounds.maxV) / 2;
                const finalCenterX = comX + (midU * Math.cos(bestTheta) - midV * Math.sin(bestTheta));
                const finalCenterY = comY + (midU * Math.sin(bestTheta) + midV * Math.cos(bestTheta));
                return { centerX: finalCenterX, centerY: finalCenterY, width: width, height: height, rotation: bestTheta, count };
            }

            function generateTemplate(type) {
                const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                if (type === 'strip') {
                    canvas.width = 600; canvas.height = 1800; ctx.fillStyle = 'white'; ctx.fillRect(0,0,600,1800);
                    ctx.clearRect(50, 50, 500, 500); ctx.clearRect(50, 650, 500, 500); ctx.clearRect(50, 1250, 500, 500);
                    numPhotosToTake = 3;
                    photoSlots = [ {centerX: 300, centerY: 300, width: 500, height: 500, rotation: 0, scale: 1, shape: 'rect'}, {centerX: 300, centerY: 900, width: 500, height: 500, rotation: 0, scale: 1, shape: 'rect'}, {centerX: 300, centerY: 1500, width: 500, height: 500, rotation: 0, scale: 1, shape: 'rect'} ];
                } else if (type === 'grid') {
                    canvas.width = 1200; canvas.height = 1200; ctx.fillStyle = 'white'; ctx.fillRect(0,0,1200,1200);
                    ctx.clearRect(50, 50, 525, 525); ctx.clearRect(625, 50, 525, 525); ctx.clearRect(50, 625, 525, 525); ctx.clearRect(625, 625, 525, 525);
                    numPhotosToTake = 4;
                    photoSlots = [ {centerX: 312.5, centerY: 312.5, width: 525, height: 525, rotation: 0, scale: 1, shape: 'rect'}, {centerX: 887.5, centerY: 312.5, width: 525, height: 525, rotation: 0, scale: 1, shape: 'rect'}, {centerX: 312.5, centerY: 887.5, width: 525, height: 525, rotation: 0, scale: 1, shape: 'rect'}, {centerX: 887.5, centerY: 887.5, width: 525, height: 525, rotation: 0, scale: 1, shape: 'rect'} ];
                }
                photoCountSelect.value = numPhotosToTake; return canvas.toDataURL('image/png');
            }

            function showNotification(msg, imageUrl = null, type = 'success') {
                if (type !== 'error') playSuccessSound();

                notificationText.textContent = msg;
                
                if (type === 'error' || type === true) { 
                    notificationToast.classList.add('error');
                    toastViewBtn.style.display = 'none';
                    toastUndoBtn.style.display = 'none';
                } else {
                    notificationToast.classList.remove('error');
                    
                    if (type === 'undo') {
                        toastViewBtn.style.display = 'none';
                        toastUndoBtn.style.display = 'block';
                        toastUndoBtn.onclick = undoLastDelete;
                    } else {
                        toastViewBtn.style.display = 'block';
                        toastUndoBtn.style.display = 'none';
                    }
                }
                
                if (imageUrl) {
                    toastThumb.src = imageUrl;
                    toastThumb.style.display = 'block';
                    toastIcon.style.display = 'none';
                } else {
                    toastThumb.style.display = 'none';
                    toastIcon.style.display = 'block';
                }

                notificationToast.classList.add('show');
                setTimeout(() => { notificationToast.classList.remove('show'); }, 4000);
            }

            toastViewBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                notificationToast.classList.remove('show'); 
                galleryModal.style.display = 'flex'; 
            });

            function showView(viewName) {
                Object.values(views).forEach(v => v.style.display = 'none');
                if (views[viewName]) views[viewName].style.display = 'flex';
                if (viewName === 'camera') {
                    cameraView.focus();
                    const filter = filterSelect.value;
                    videoEl.style.filter = filter; aiCanvas.style.filter = filter;
                    if(mirrorToggle.checked) { videoEl.classList.add('mirrored'); aiCanvas.classList.add('mirrored'); } 
                    else { videoEl.classList.remove('mirrored'); aiCanvas.classList.remove('mirrored'); }
                    if (useTemplate && templateImage.src) { liveTemplateImg.src = templateImage.src; liveTemplateImg.style.display = templateOverlayEnabled ? 'block' : 'none'; } 
                    else { liveTemplateImg.style.display = 'none'; }
                }
            }

            async function enumerateCameras() {
                cameraSelect.innerHTML = '<option value="">Loading cameras...</option>';
                try {
                    const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    tempStream.getTracks().forEach(track => track.stop());
                    cameraSelect.innerHTML = ''; 
                    if (videoDevices.length === 0) cameraSelect.innerHTML = '<option value="">No cameras found</option>';
                    else {
                        videoDevices.forEach(device => { const option = document.createElement('option'); option.value = device.deviceId; option.textContent = device.label || `Camera ${cameraSelect.options.length + 1}`; cameraSelect.appendChild(option); });
                        cameraSelect.selectedIndex = 0;
                    }
                } catch (err) { console.error("Error accessing camera:", err); cameraSelect.innerHTML = '<option value="">Camera access denied</option>'; }
            }

            qsStripBtn.addEventListener('click', () => { 
                templateImage.src = generateTemplate('strip'); 
                useTemplate = true; 
                isQuickStart = true; 
                templateImage.onload = () => { updateTemplateImageData(templateImage); analyzeTemplateHoles(); saveState(); showView('camera'); startCamera(); }; 
            });
            qsGridBtn.addEventListener('click', () => { 
                templateImage.src = generateTemplate('grid'); 
                useTemplate = true; 
                isQuickStart = true; 
                templateImage.onload = () => { updateTemplateImageData(templateImage); analyzeTemplateHoles(); saveState(); showView('camera'); startCamera(); }; 
            });
            qsGridBtn.addEventListener('click', () => { 
                templateImage.src = generateTemplate('grid'); 
                useTemplate = true; 
                isQuickStart = true; 
                templateImage.onload = () => { updateTemplateImageData(templateImage); saveState(); showView('camera'); startCamera(); }; 
            });

            templateInput.addEventListener('change', () => {
                const file = templateInput.files[0];
                if (file && file.type === 'image/png') {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        templateImage.src = e.target.result;
                        templateImage.onload = () => {
                            fileNameEl.textContent = file.name; startBtn.style.display = 'block'; startBtn.disabled = false;
                            const detected = detectTemplateSlots(templateImage);
                            if (detected.length > 0) { photoSlots = detected; numPhotosToTake = detected.length; photoCountSelect.value = numPhotosToTake; autoMapMsg.textContent = `âœ¨ Auto-mapped ${numPhotosToTake} photo slots!`; autoMapMsg.style.display = 'block'; } 
                            else { photoSlots = []; autoMapMsg.style.display = 'none'; }
                        };
                    };
                    reader.readAsDataURL(file);
                }
            });

            photoCountSelect.addEventListener('change', () => { numPhotosToTake = parseInt(photoCountSelect.value, 10); if (views.mapping.style.display === 'flex') setupMappingView(); });
            
            startBtn.addEventListener('click', () => { 
                useTemplate = true; 
                isQuickStart = false; 
                setupMappingView(); 
                showView('mapping'); 
            });
            
            // CHANGED: Force 1 shot when starting Freestyle
            startNoTemplateBtn.addEventListener('click', () => { 
                useTemplate = false; 
                numPhotosToTake = 1;
                photoCountSelect.value = 1; // Sync Settings UI
                showView('camera'); 
                startCamera(); 
            });

            filterSelect.addEventListener('change', () => { const filter = filterSelect.value; videoEl.style.filter = filter; aiCanvas.style.filter = filter; document.getElementById('photo-preview-overlay').style.filter = filter; });
            toggleOverlayBtn.addEventListener('click', () => { templateOverlayEnabled = !templateOverlayEnabled; toggleOverlayBtn.classList.toggle('active'); liveTemplateImg.style.display = templateOverlayEnabled && useTemplate ? 'block' : 'none'; });

            toolRect.addEventListener('click', () => { mappingState.drawingShape = 'rect'; toolRect.classList.add('active'); toolCircle.classList.remove('active'); });
            toolCircle.addEventListener('click', () => { mappingState.drawingShape = 'circle'; toolCircle.classList.add('active'); toolRect.classList.remove('active'); });
            toolSnap.addEventListener('click', () => { mappingState.snapEnabled = !mappingState.snapEnabled; toolSnap.classList.toggle('active'); });
            toolRatio.addEventListener('click', () => {
                if (!mappingState.aspectRatio) { mappingState.aspectRatio = 4/3; toolRatio.textContent = "4:3"; }
                else if (mappingState.aspectRatio === 4/3) { mappingState.aspectRatio = 16/9; toolRatio.textContent = "16:9"; }
                else { mappingState.aspectRatio = null; toolRatio.textContent = "Free"; }
            });

            function setupMappingView() {
                mappingState.selectedIndex = -1; mappingState.isCreating = false; mappingState.isDragging = false;
                const templateAspect = templateImage.width / templateImage.height;
                const maxW = window.innerWidth * 0.95; const maxH = (window.innerHeight - 250); 
                let displayW = maxW; let displayH = maxW / templateAspect;
                if (displayH > maxH || displayH < 100) { displayH = maxH; displayW = maxH * templateAspect; }
                if (displayW > maxW) { displayW = maxW; displayH = maxW / templateAspect; }
                mappingCanvas.width = displayW; mappingCanvas.height = displayH;
                updateMappingInstructions(); drawCurrentMapping(); updateButtonStates(); mappingCanvas.focus();
            }

            function updateButtonStates() { 
                undoBtn.disabled = photoSlots.length === 0; 
                startMappedBtn.style.display = photoSlots.length === numPhotosToTake ? 'block' : 'none';
                mappingControlsPanel.classList.toggle('hidden', mappingState.selectedIndex === -1);
                if(mappingState.selectedIndex !== -1) {
                    const s = photoSlots[mappingState.selectedIndex];
                    slotInfoLabel.textContent = `Slot #${mappingState.selectedIndex + 1}`;
                    scaleValueLabel.textContent = `Scale: ${Math.round(s.scale * 100)}%`;
                    let deg = Math.round(s.rotation * 180 / Math.PI);
                    deg = deg % 360;
                    if (deg > 180) deg -= 360;
                    if (deg <= -180) deg += 360;
                    rotationSlider.value = deg;
                    rotationDisplay.textContent = `${deg}Â°`;
                }
            }

            function updateMappingInstructions() {
                if (photoSlots.length === numPhotosToTake && mappingState.selectedIndex === -1) { mappingInstructions.textContent = "All slots filled! Click 'Start PhotoBooth' or select a slot to edit."; } 
                else if (mappingState.selectedIndex !== -1) { mappingInstructions.textContent = "Use slider to rotate. Drag corners to resize."; } 
                else { mappingInstructions.innerHTML = `Draw Slot **${photoSlots.length + 1}/${numPhotosToTake}**. Click inside holes to Auto-Detect.`; }
            }

            rotationSlider.addEventListener('input', (e) => {
                if (mappingState.selectedIndex === -1) return;
                const s = photoSlots[mappingState.selectedIndex];
                const deg = parseInt(e.target.value);
                s.rotation = deg * Math.PI / 180;
                rotationDisplay.textContent = `${deg}Â°`;
                drawCurrentMapping();
            });

            rotationSlider.addEventListener('change', saveState);

            function rotateSelectedSlot(angleDeg) {
                if (mappingState.selectedIndex === -1) return;
                const s = photoSlots[mappingState.selectedIndex];
                let deg = Math.round(s.rotation * 180 / Math.PI);
                deg += angleDeg;
                s.rotation = deg * Math.PI / 180;
                drawCurrentMapping();
                updateButtonStates(); 
                saveState();
            }

            rotCCW.addEventListener('click', () => rotateSelectedSlot(-90));
            rotCW.addEventListener('click', () => rotateSelectedSlot(90));
            
            function drawRotatedRect(ctx, slot, scaleX, scaleY, color, label, isSelected) {
                const dispCX = slot.centerX * scaleX; const dispCY = slot.centerY * scaleY; 
                const dispW = (slot.width * scaleX) * slot.scale; const dispH = (slot.height * scaleY) * slot.scale;
                ctx.save(); ctx.translate(dispCX, dispCY); ctx.rotate(slot.rotation); 
                ctx.strokeStyle = color; ctx.lineWidth = isSelected ? 3 : 2;
                if (slot.shape === 'circle') { ctx.beginPath(); ctx.ellipse(0, 0, dispW/2, dispH/2, 0, 0, 2 * Math.PI); ctx.stroke(); } 
                else { ctx.strokeRect(-dispW / 2, -dispH / 2, dispW, dispH); }
                if (isSelected) { ctx.fillStyle = '#fff'; const hSize = 8; ctx.fillRect(-dispW/2 - hSize/2, -dispH/2 - hSize/2, hSize, hSize); ctx.fillRect(dispW/2 - hSize/2, -dispH/2 - hSize/2, hSize, hSize); ctx.fillRect(-dispW/2 - hSize/2, dispH/2 - hSize/2, hSize, hSize); ctx.fillRect(dispW/2 - hSize/2, dispH/2 - hSize/2, hSize, hSize); }
                ctx.fillStyle = color; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(label, 0, 0); ctx.restore();
            }

            function drawCurrentMapping() {
                const displayW = mappingCanvas.width; const displayH = mappingCanvas.height; 
                const scaleX = displayW / templateImage.width; const scaleY = displayH / templateImage.height;
                mappingCtx.clearRect(0, 0, displayW, displayH); mappingCtx.drawImage(templateImage, 0, 0, displayW, displayH);
                
                if (mappingState.snapEnabled) {
                    mappingCtx.save();
                    mappingCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    mappingCtx.lineWidth = 1;
                    detectedHoles.forEach(hole => {
                        const hx = hole.centerX * scaleX;
                        const hy = hole.centerY * scaleY;
                        mappingCtx.beginPath();
                        mappingCtx.moveTo(hx - 5, hy); mappingCtx.lineTo(hx + 5, hy);
                        mappingCtx.moveTo(hx, hy - 5); mappingCtx.lineTo(hx, hy + 5);
                        mappingCtx.stroke();
                    });
                    mappingCtx.restore();
                }

                photoSlots.forEach((slot, index) => { drawRotatedRect(mappingCtx, slot, scaleX, scaleY, index === mappingState.selectedIndex ? '#00ff00' : '#ffcc00', `${index + 1}`, index === mappingState.selectedIndex); });
                if (mappingState.isCreating) {
                    const w = mappingState.tempX - mappingState.startX; const h = mappingState.tempY - mappingState.startY;
                    mappingCtx.strokeStyle = 'cyan'; mappingCtx.lineWidth = 2; mappingCtx.setLineDash([5, 5]); 
                    if (mappingState.drawingShape === 'circle') { const rx = Math.abs(w)/2; const ry = Math.abs(h)/2; const cx = mappingState.startX + w/2; const cy = mappingState.startY + h/2; mappingCtx.beginPath(); mappingCtx.ellipse(cx, cy, rx, ry, 0, 0, 2*Math.PI); mappingCtx.stroke(); } 
                    else { mappingCtx.strokeRect(mappingState.startX, mappingState.startY, w, h); }
                    mappingCtx.setLineDash([]); 
                }
            }

            function getCoords(e) {
                const rect = mappingCanvas.getBoundingClientRect(); 
                let clientX, clientY; 
                if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } else { clientX = e.clientX; clientY = e.clientY; }
                const screenX = clientX - rect.left; 
                const screenY = clientY - rect.top; 
                const domScaleX = mappingCanvas.width / rect.width;
                const domScaleY = mappingCanvas.height / rect.height;
                const canvasX = screenX * domScaleX;
                const canvasY = screenY * domScaleY;
                const imgScaleX = templateImage.width / mappingCanvas.width;
                const imgScaleY = templateImage.height / mappingCanvas.height;
                const originalX = canvasX * imgScaleX;
                const originalY = canvasY * imgScaleY;
                return { canvasX, canvasY, originalX, originalY };
            }

            function hitTest(x, y) {
                const scaleX = mappingCanvas.width / templateImage.width; const scaleY = mappingCanvas.height / templateImage.height;
                if (mappingState.selectedIndex !== -1) {
                    const s = photoSlots[mappingState.selectedIndex];
                    const dispCX = s.centerX * scaleX; const dispCY = s.centerY * scaleY;
                    const dispW = (s.width * scaleX) * s.scale; const dispH = (s.height * scaleY) * s.scale; const hSize = 15;
                    const dx = x - dispCX; const dy = y - dispCY;
                    const rx = dx * Math.cos(-s.rotation) - dy * Math.sin(-s.rotation); const ry = dx * Math.sin(-s.rotation) + dy * Math.cos(-s.rotation);
                    if (Math.abs(rx - (-dispW/2)) < hSize && Math.abs(ry - (-dispH/2)) < hSize) return { index: mappingState.selectedIndex, type: 'tl' };
                    if (Math.abs(rx - (dispW/2)) < hSize && Math.abs(ry - (-dispH/2)) < hSize) return { index: mappingState.selectedIndex, type: 'tr' };
                    if (Math.abs(rx - (-dispW/2)) < hSize && Math.abs(ry - (dispH/2)) < hSize) return { index: mappingState.selectedIndex, type: 'bl' };
                    if (Math.abs(rx - (dispW/2)) < hSize && Math.abs(ry - (dispH/2)) < hSize) return { index: mappingState.selectedIndex, type: 'br' };
                }
                for (let i = photoSlots.length - 1; i >= 0; i--) {
                    const s = photoSlots[i];
                    const dispCX = s.centerX * scaleX; const dispCY = s.centerY * scaleY;
                    const dispW = (s.width * scaleX) * s.scale; const dispH = (s.height * scaleY) * s.scale;
                    const dx = x - dispCX; const dy = y - dispCY;
                    const rx = dx * Math.cos(-s.rotation) - dy * Math.sin(-s.rotation); const ry = dx * Math.sin(-s.rotation) + dy * Math.cos(-s.rotation);
                    if (Math.abs(rx) < dispW/2 && Math.abs(ry) < dispH/2) return { index: i, type: 'move' };
                }
                return null;
            }

            function updateMagnifier(canvasX, canvasY) {
                if (!mappingState.isDragging && !mappingState.isCreating) { magnifier.style.display = 'none'; return; }
                const rect = mappingCanvas.getBoundingClientRect();
                const domScaleX = rect.width / mappingCanvas.width;
                const domScaleY = rect.height / mappingCanvas.height;
                const screenX = canvasX * domScaleX;
                const screenY = canvasY * domScaleY;
                magnifier.style.display = 'block'; 
                magnifier.style.left = (screenX + 20) + 'px'; 
                magnifier.style.top = (screenY - 60) + 'px'; 
                const zoom = 2; 
                magnifier.style.backgroundImage = `url(${templateImage.src})`; 
                const scaleX = templateImage.width / mappingCanvas.width;
                const scaleY = templateImage.height / mappingCanvas.height;
                const imgX = canvasX * scaleX;
                const imgY = canvasY * scaleY;
                magnifier.style.backgroundSize = `${templateImage.width * zoom}px ${templateImage.height * zoom}px`; 
                magnifier.style.backgroundPosition = `-${imgX * zoom - 50}px -${imgY * zoom - 50}px`;
            }

            mappingCanvas.addEventListener('mousedown', (e) => {
                e.preventDefault(); 
                const coords = getCoords(e); 
                const hit = hitTest(coords.canvasX, coords.canvasY);
                if (hit) {
                    mappingState.selectedIndex = hit.index; mappingState.dragType = hit.type; mappingState.isDragging = true;
                    mappingState.dragOffsetX = coords.originalX; mappingState.dragOffsetY = coords.originalY;
                    const s = photoSlots[hit.index]; mappingState.baseWidth = s.width * s.scale; mappingState.baseHeight = s.height * s.scale; mappingState.baseCenterX = s.centerX; mappingState.baseCenterY = s.centerY;
                } else {
                    if (mappingState.selectedIndex !== -1) { mappingState.selectedIndex = -1; updateButtonStates(); drawCurrentMapping(); return; }
                    let magicWandSuccess = false;
                    if (templateImageData) {
                        const ix = Math.floor(coords.originalX); const iy = Math.floor(coords.originalY);
                        if (ix >= 0 && ix < templateImageData.width && iy >= 0 && iy < templateImageData.height) {
                            const idx = (iy * templateImageData.width + ix) * 4;
                            if (templateImageData.data[idx + 3] < 50) {
                                const visited = new Uint8Array(templateImageData.width * templateImageData.height); 
                                const region = performFloodFillMoments(ix, iy, templateImageData.width, templateImageData.height, templateImageData.data, visited);
                                if (region.count > 400 && photoSlots.length < numPhotosToTake) { photoSlots.push({ centerX: region.centerX, centerY: region.centerY, width: region.width + 2, height: region.height + 2, rotation: region.rotation, scale: 1, shape: mappingState.drawingShape }); mappingState.selectedIndex = photoSlots.length - 1; saveState(); magicWandSuccess = true; }
                            }
                        }
                    }
                    if (!magicWandSuccess && photoSlots.length < numPhotosToTake) { 
                        mappingState.isCreating = true; 
                        mappingState.startX = coords.canvasX; mappingState.startY = coords.canvasY; 
                        mappingState.tempX = coords.canvasX; mappingState.tempY = coords.canvasY; 
                    }
                }
                updateButtonStates(); drawCurrentMapping();
            });

            mappingCanvas.addEventListener('mousemove', (e) => {
                const coords = getCoords(e); 
                updateMagnifier(coords.canvasX, coords.canvasY);
                if (mappingState.isDragging && mappingState.selectedIndex !== -1) {
                    const s = photoSlots[mappingState.selectedIndex];
                    const dX = (coords.originalX - mappingState.dragOffsetX); const dY = (coords.originalY - mappingState.dragOffsetY);
                    let snapX = 0, snapY = 0;
                    let isAutoFitted = false;
                    if (mappingState.snapEnabled && mappingState.dragType === 'move') { 
                        photoSlots.forEach((other, idx) => { 
                            if (idx !== mappingState.selectedIndex) { 
                                if (Math.abs((mappingState.baseCenterX + dX) - other.centerX) < 20) snapX = other.centerX - (mappingState.baseCenterX + dX); 
                                if (Math.abs((mappingState.baseCenterY + dY) - other.centerY) < 20) snapY = other.centerY - (mappingState.baseCenterY + dY); 
                            } 
                        }); 
                        detectedHoles.forEach(hole => {
                             const dist = Math.sqrt(Math.pow((mappingState.baseCenterX + dX) - hole.centerX, 2) + Math.pow((mappingState.baseCenterY + dY) - hole.centerY, 2));
                             if (dist < 25) {
                                 snapX = hole.centerX - (mappingState.baseCenterX + dX);
                                 snapY = hole.centerY - (mappingState.baseCenterY + dY);
                                 s.rotation = hole.rotation;
                                 s.width = hole.width;
                                 s.height = hole.height;
                                 s.scale = 1; 
                                 isAutoFitted = true;
                             }
                        });
                    }
                    if (mappingState.dragType === 'move') { 
                        s.centerX = mappingState.baseCenterX + dX + snapX; 
                        s.centerY = mappingState.baseCenterY + dY + snapY; 
                    } 
                    else {
                        const cos = Math.cos(-s.rotation); const sin = Math.sin(-s.rotation); const rotDX = dX * cos - dY * sin; const rotDY = dX * sin + dY * cos;
                        let wChange = 0, hChange = 0;
                        if (mappingState.dragType === 'br') { wChange = rotDX; hChange = rotDY; } else if (mappingState.dragType === 'tl') { wChange = -rotDX; hChange = -rotDY; } else if (mappingState.dragType === 'tr') { wChange = rotDX; hChange = -rotDY; } else if (mappingState.dragType === 'bl') { wChange = -rotDX; hChange = rotDY; }
                        let newW = (mappingState.baseWidth + wChange * 2); let newH = (mappingState.baseHeight + hChange * 2);
                        if (mappingState.aspectRatio) { newH = newW / mappingState.aspectRatio; }
                        if (newW > 10) s.width = newW / s.scale; if (newH > 10) s.height = newH / s.scale;
                    }
                    drawCurrentMapping(); 
                    if (isAutoFitted) updateButtonStates(); 
                    updateButtonStates();
                } else if (mappingState.isCreating) {
                    mappingState.tempX = coords.canvasX; mappingState.tempY = coords.canvasY;
                    if (mappingState.aspectRatio) { const w = mappingState.tempX - mappingState.startX; mappingState.tempY = mappingState.startY + (Math.abs(w) / mappingState.aspectRatio) * Math.sign(mappingState.tempY - mappingState.startY); }
                    drawCurrentMapping();
                } else {
                    const hit = hitTest(coords.canvasX, coords.canvasY);
                    if (hit) { mappingCanvas.style.cursor = (hit.type === 'move') ? 'move' : ((hit.type === 'tl' || hit.type === 'br') ? 'nwse-resize' : 'nesw-resize'); } else { mappingCanvas.style.cursor = 'crosshair'; }
                }
            });

            mappingCanvas.addEventListener('mouseup', (e) => {
                magnifier.style.display = 'none';
                if (mappingState.isCreating) {
                    const coords = getCoords(e);
                    const scaleX = templateImage.width / mappingCanvas.width; 
                    const scaleY = templateImage.height / mappingCanvas.height;
                    const canvasW = Math.abs(coords.canvasX - mappingState.startX);
                    const canvasH = Math.abs(coords.canvasY - mappingState.startY);
                    const w = canvasW * scaleX;
                    const h = canvasH * scaleY;
                    if (w > 10 && h > 10) {
                        const imgStartX = mappingState.startX * scaleX;
                        const imgStartY = mappingState.startY * scaleY;
                        const cx = imgStartX + (coords.originalX - imgStartX) / 2;
                        const cy = imgStartY + (coords.originalY - imgStartY) / 2;
                        photoSlots.push({ centerX: cx, centerY: cy, width: w, height: h, rotation: 0, scale: 1, shape: mappingState.drawingShape }); mappingState.selectedIndex = photoSlots.length - 1; saveState();
                    }
                    mappingState.isCreating = false; updateButtonStates(); drawCurrentMapping();
                }
                mappingState.isDragging = false;
            });

            document.addEventListener('keydown', (e) => {
                if (views.mapping.style.display === 'flex' && mappingState.selectedIndex !== -1) {
                    const s = photoSlots[mappingState.selectedIndex]; const shift = e.shiftKey ? 10 : 1;
                    if (e.key === 'ArrowLeft') { s.centerX -= shift; e.preventDefault(); }
                    if (e.key === 'ArrowRight') { s.centerX += shift; e.preventDefault(); }
                    if (e.key === 'ArrowUp') { s.centerY -= shift; e.preventDefault(); }
                    if (e.key === 'ArrowDown') { s.centerY += shift; e.preventDefault(); }
                    if (e.key === 'Delete' || e.key === 'Backspace') { deleteSlotBtn.click(); }
                    drawCurrentMapping(); updateButtonStates();
                }
                if (e.key === "Escape") { 
                    if (closePreviewBtn.style.display !== 'none') {
                        closePreviewBtn.click();
                        return;
                    }
                    if (views.camera.style.display === 'flex') exitCamera();
                    galleryModal.style.display = 'none';
                    settingsModal.style.display = 'none';
                }
                if (views.camera.style.display === 'flex' && e.code === 'Space') { e.preventDefault(); if (captureBtn.style.display !== 'none') captureBtn.click(); }
                if(views.preview.style.display === 'flex') {
                    if(e.key.toLowerCase() === 'p') printBtn.click();
                    if(e.key.toLowerCase() === 's') saveBtn.click();
                    if(e.key.toLowerCase() === 'r' && retakeBtn.style.display !== 'none') retakeBtn.click();
                }
                if(e.key.toLowerCase() === 'g') galleryModal.style.display = (galleryModal.style.display === 'none' ? 'flex' : 'none');
            });

            deleteSlotBtn.addEventListener('click', () => { if (mappingState.selectedIndex !== -1) { photoSlots.splice(mappingState.selectedIndex, 1); mappingState.selectedIndex = -1; drawCurrentMapping(); updateButtonStates(); saveState(); } });
            confirmAdjustmentBtn.addEventListener('click', () => { mappingState.selectedIndex = -1; drawCurrentMapping(); updateButtonStates(); saveState(); });

            function exitCamera() {
                if (isCountingDown) {
                    if (countdownInterval) clearInterval(countdownInterval);
                    countdownInterval = null;
                    countdownEl.style.display = 'none';
                    countdownEl.classList.remove('animate', 'is-arrow');
                    cropFrameOverlay.style.display = 'none';
                    cameraControls.classList.remove('controls-hidden');
                    captureBtn.style.display = 'block'; 
                    isCountingDown = false;
                    updateCameraCropVisual(); 
                    return; 
                }
                stopCamera(); 
                capturedPhotos = []; 
                photoCount = 0; 
                cropFrameOverlay.style.display = 'none'; 
                cameraControls.classList.remove('controls-hidden'); 
                if (useTemplate && !isQuickStart) { 
                    setupMappingView(); 
                    showView('mapping'); 
                } else { 
                    showView('template'); 
                }
                isCountingDown = false;
            }
            closeCameraBtn.addEventListener('click', exitCamera);

            function killCameraStream() {
                if (stream) {
                    stream.getTracks().forEach(track => {
                        track.stop();
                        track.enabled = false;
                    });
                    stream = null;
                }
                videoEl.srcObject = null;
            }

            async function startCamera(retryCount = 0) {
                if (retakeIndex === null) { capturedPhotos = []; photoCount = 0; } else { photoCount = retakeIndex; } 
                updatePhotoCounter(); 
                renderCapturedThumbnails(); 
                captureBtn.style.display = 'block'; cropFrameOverlay.style.display = 'none'; 
                let selectedDeviceId = cameraSelect.value;
                const driverMode = driverModeSelect.value; 
                if (selectedDeviceId === "" || selectedDeviceId === "Loading cameras...") { selectedDeviceId = undefined; }
                const settingsChanged = (lastUsedDriverMode !== driverMode);
                if (stream && stream.active && videoEl.srcObject && !settingsChanged) {
                    const track = stream.getVideoTracks()[0];
                    if (track.readyState === 'live') {
                        const settings = track.getSettings();
                        if (!selectedDeviceId || settings.deviceId === selectedDeviceId) {
                            console.log("Camera is already live. Resuming playback.");
                            try { await videoEl.play(); } catch(e) { console.log("Resume play caught:", e); }
                            cameraControls.classList.remove('controls-hidden');
                            try {
                                const caps = track.getCapabilities();
                                if (caps && caps.zoom) zoomContainer.style.display = 'flex';
                            } catch(e) {}
                            if (aiBlurEnabled) startVideoProcessing();
                            if (!aiBlurEnabled) videoEl.style.opacity = 1;
                            return; 
                        }
                    }
                }
                if (stream) {
                    killCameraStream(); 
                    console.log("Releasing camera driver for restart...");
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                lastUsedDriverMode = driverMode; 
                let constraintSets = [];
                if (driverMode === 'sony') {
                    constraintSets = [{ 
                        video: { 
                            width: { min: 1024, ideal: 1024, max: 1024 }, 
                            height: { min: 576, ideal: 576, max: 576 }, 
                            deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined 
                        }, 
                        audio: false 
                    }];
                } else if (driverMode === 'hd') {
                    constraintSets = [{ 
                        video: { 
                            width: { ideal: 1280 }, 
                            height: { ideal: 720 }, 
                            deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined 
                        }, 
                        audio: false 
                    }];
                } else if (driverMode === 'vga') {
                    constraintSets = [{ 
                        video: { 
                            width: { ideal: 640 }, 
                            height: { ideal: 480 }, 
                            deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined 
                        }, 
                        audio: false 
                    }];
                } else {
                    constraintSets = [
                        { video: { width: { ideal: 1280 }, height: { ideal: 720 }, deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined }, audio: false },
                        { video: { width: { min: 1024, max: 1024 }, height: { min: 576, max: 576 }, deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined }, audio: false },
                        { video: { width: { ideal: 640 }, height: { ideal: 480 }, deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined }, audio: false },
                        { video: { deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined }, audio: false }
                    ];
                }
                let activeStream = null;
                let connectError = null;
                for (const constraints of constraintSets) {
                    try {
                        console.log("Attempting camera connection with:", JSON.stringify(constraints.video));
                        activeStream = await navigator.mediaDevices.getUserMedia(constraints);
                        console.log("Camera connected successfully.");
                        break; 
                    } catch (err) {
                        console.warn("Connection attempt failed:", err.name);
                        connectError = err;
                    }
                }
                if (!activeStream) {
                    if (retryCount < 3) {
                        console.log(`Camera failed. Retrying (${retryCount + 1}/3) in 0.5s...`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                        return startCamera(retryCount + 1);
                    }
                    console.error("CRITICAL: All camera attempts failed.", connectError);
                    alert("Camera Error: Could not connect. Try changing 'Driver Fix' in Settings to 'Safe Mode' or check if another app is using the camera.");
                    stopCamera(); 
                    showView('template');
                    return;
                }
                stream = activeStream;
                videoEl.srcObject = stream;
                videoEl.setAttribute('autoplay', '');
                videoEl.setAttribute('muted', '');
                videoEl.setAttribute('playsinline', '');
                videoEl.onloadedmetadata = () => {
                    videoEl.play().then(() => {
                        cameraControls.classList.remove('controls-hidden');
                        videoTrack = stream.getVideoTracks()[0];
                        try {
                            const caps = videoTrack.getCapabilities();
                            if (caps && caps.zoom) {
                                zoomContainer.style.display = 'flex'; 
                                zoomSlider.min = caps.zoom.min; 
                                zoomSlider.max = caps.zoom.max; 
                                zoomSlider.step = caps.zoom.step; 
                                zoomSlider.value = caps.zoom.min;
                            } else { 
                                zoomContainer.style.display = 'none'; 
                            }
                        } catch(e) {
                            zoomContainer.style.display = 'none'; 
                        }
                        if (!aiBlurEnabled) {
                            videoEl.style.opacity = 1;
                        } else {
                            startVideoProcessing();
                        }
                    }).catch(e => console.error("Play failed:", e));
                };
            }
            
            function stopCamera() { 
                cancelAnimationFrame(animationFrameId); 
                videoEl.pause(); 
                cameraControls.classList.remove('controls-hidden'); 
            }
            
            zoomSlider.addEventListener('input', () => { if (videoTrack) videoTrack.applyConstraints({ advanced: [{ zoom: zoomSlider.value }] }); });

            function updateCameraCropVisual() {
                if (!useTemplate) { cropFrameOverlay.style.display = 'none'; return; }
                const currentSlot = retakeIndex !== null ? retakeIndex : photoCount;
                if (currentSlot >= numPhotosToTake) { cropFrameOverlay.style.display = 'none'; return; }
                let requiredRatio = TARGET_ASPECT_RATIO;
                if (photoSlots[currentSlot]) requiredRatio = photoSlots[currentSlot].width / photoSlots[currentSlot].height;
                const vw = window.innerWidth; 
                const vh = window.innerHeight; 
                let frameW, frameH;
                if (vw / vh > requiredRatio) {
                    frameH = vh;
                    frameW = vh * requiredRatio;
                } else {
                    frameW = vw;
                    frameH = vw / requiredRatio;
                }
                frameW = Math.min(frameW, vw);
                frameH = Math.min(frameH, vh);
                cropFrameOverlay.style.width = `${frameW}px`; 
                cropFrameOverlay.style.height = `${frameH}px`; 
                cropFrameOverlay.style.display = 'block';
                if (photoSlots[currentSlot].shape === 'circle') cropFrameOverlay.style.borderRadius = '50%'; else cropFrameOverlay.style.borderRadius = '0';
            }
            
            captureBtn.addEventListener('click', () => { if (videoEl.paused || videoEl.readyState < 3) return; captureBtn.style.display = 'none'; startCountdown(); });
            
            function triggerFlash() {
                flashOverlay.classList.remove('flash-active');
                void flashOverlay.offsetWidth; 
                flashOverlay.classList.add('flash-active');
                setTimeout(() => { flashOverlay.classList.remove('flash-active'); }, 400);
            }

            function startCountdown() {
                if (isCountingDown) return; isCountingDown = true;
                const selectedTimer = parseInt(timerSelect.value) || 5; let count = selectedTimer; 
                if (countdownInterval) clearInterval(countdownInterval);
                cameraControls.classList.add('controls-hidden');
                countdownEl.style.display = ''; countdownEl.textContent = count; countdownEl.classList.remove('is-arrow'); triggerCountdownAnimation(); playBeep(); updateCameraCropVisual();
                countdownInterval = setInterval(() => {
                    count--;
                    if (count > 1) { countdownEl.textContent = count; countdownEl.classList.remove('is-arrow'); triggerCountdownAnimation(); playBeep(); } 
                    else if (count === 1) { countdownEl.textContent = 'ðŸ‘†'; countdownEl.classList.add('is-arrow'); triggerCountdownAnimation(); playBeep(); } 
                    else { 
                        clearInterval(countdownInterval); countdownInterval = null; countdownEl.textContent = ''; triggerCountdownAnimation(); cropFrameOverlay.style.display = 'none'; 
                        playShutter(); 
                        if (flashEnabled) { triggerFlash(); }
                        setTimeout(() => { countdownEl.style.display = 'none'; countdownEl.classList.remove('is-arrow'); takePhoto(); }, 300);
                    }
                }, 1000);
            }
            function triggerCountdownAnimation() { countdownEl.classList.remove('animate'); void countdownEl.offsetWidth; countdownEl.classList.add('animate'); }

            function takePhoto() {
                const photoPreviewEl = document.getElementById('photo-preview-overlay'); 
                const currentSlotIndex = retakeIndex !== null ? retakeIndex : photoCount;
                const sourceEl = aiBlurEnabled ? aiCanvas : videoEl;
                let sourceW, sourceH; if (aiBlurEnabled) { sourceW = aiCanvas.width; sourceH = aiCanvas.height; } else { sourceW = videoEl.videoWidth; sourceH = videoEl.videoHeight; }
                const videoAspect = sourceW / sourceH;
                let requiredAspectRatio = TARGET_ASPECT_RATIO;
                if (useTemplate && photoSlots[currentSlotIndex]) requiredAspectRatio = photoSlots[currentSlotIndex].width / photoSlots[currentSlotIndex].height; 
                let sX = 0, sY = 0, sW = sourceW, sH = sourceH;
                if (videoAspect > requiredAspectRatio) { sW = sourceH * requiredAspectRatio; sX = (sourceW - sW) / 2; } else { sH = sourceW / requiredAspectRatio; sY = (sourceH - sH) / 2; }
                captureCanvas.width = sW; captureCanvas.height = sH;
                captureCtx.save(); captureCtx.filter = filterSelect.value;
                captureCtx.drawImage(sourceEl, sX, sY, sW, sH, 0, 0, sW, sH); captureCtx.restore();
                const currentPhotoDataUrl = captureCanvas.toDataURL('image/jpeg', 0.95);
                if (retakeIndex !== null) { capturedPhotos[retakeIndex] = currentPhotoDataUrl; } else { capturedPhotos.push(currentPhotoDataUrl); photoCount++; }
                updatePhotoCounter(); 
                photoPreviewEl.src = currentPhotoDataUrl; photoPreviewEl.style.filter = filterSelect.value;
                const randomTilt = Math.random() * 6 - 3; 
                const scaleX = mirrorToggle.checked ? -1.1 : 1.1;
                photoPreviewEl.style.transform = `translate(-50%, -50%) scale(${scaleX}, 1.1) rotate(${randomTilt}deg)`; 
                photoPreviewEl.classList.add('show-preview');

                // Stats: Update Photos Taken
                stats.photos++;
                saveStats();

                setTimeout(() => { 
                    photoPreviewEl.classList.remove('show-preview'); photoPreviewEl.style.transform = ''; photoPreviewEl.src = ''; isCountingDown = false;
                    renderCapturedThumbnails(); 
                    if (retakeIndex !== null) { retakeIndex = null; stopCamera(); createFinalImage(); } 
                    else { if (photoCount < numPhotosToTake) { startCountdown(); } else { stopCamera(); createFinalImage(); } } 
                }, 2000);
            }

            function renderCapturedThumbnails() {
                capturedThumbnailsEl.innerHTML = '';
                capturedPhotos.forEach((src, index) => {
                    const img = document.createElement('img');
                    img.src = src;
                    img.className = 'cap-thumb';
                    if (retakeIndex !== null && index === retakeIndex) {
                        img.classList.add('active-retake');
                    }
                    capturedThumbnailsEl.appendChild(img);
                });
            }

            function updatePhotoCounter() { if (retakeIndex !== null) photoCounterEl.textContent = `Retaking Photo ${retakeIndex + 1}`; else photoCounterEl.textContent = `${photoCount} / ${numPhotosToTake}`; }

            function createFinalImage() {
                showView('preview'); const photoImages = []; let imagesLoaded = 0;
                capturedPhotos.forEach((dataURL, index) => { const img = new Image(); img.onload = () => { imagesLoaded++; if (imagesLoaded === capturedPhotos.length) { if (useTemplate) drawWithTemplate(photoImages); else drawWithoutTemplate(photoImages); } }; img.src = dataURL; photoImages[index] = img; });
                remapBtn.style.display = useTemplate ? 'block' : 'none'; 
                cameraControls.classList.remove('controls-hidden');
                closePreviewBtn.style.display = 'none'; 
                homeBtn.style.display = 'inline-flex'; 
                retakeBtn.style.display = 'inline-flex'; 
            }
            
            function finalizeDraw() {
                saveToGallery(mergeCanvas.toDataURL('image/jpeg', 0.60));
                
                // Stats: Update Sessions Completed
                stats.sessions++;
                saveStats();

                remapBtn.style.display = useTemplate ? 'block' : 'none'; 
                cameraControls.classList.remove('controls-hidden');
                closePreviewBtn.style.display = 'none'; 
                homeBtn.style.display = 'inline-flex';
                retakeBtn.style.display = 'inline-flex'; 
            }
            
            function drawWithoutTemplate(photoImages) { 
                const photoW = photoImages[0].width; const photoH = photoImages[0].height; 
                mergeCanvas.width = photoW; mergeCanvas.height = photoH * numPhotosToTake; 
                mergeCtx.clearRect(0, 0, mergeCanvas.width, mergeCanvas.height); 
                photoImages.forEach((img, index) => { mergeCtx.drawImage(img, 0, photoH * index, photoW, photoH); }); 
                finalizeDraw();
            }
            function drawWithTemplate(photoImages) {
                const templateW = templateImage.width; const templateH = templateImage.height; mergeCanvas.width = templateW; mergeCanvas.height = templateH; mergeCtx.clearRect(0, 0, templateW, templateH);
                photoImages.forEach((img, index) => { 
                    if (!photoSlots[index]) return; 
                    const coords = photoSlots[index]; mergeCtx.save(); mergeCtx.translate(coords.centerX, coords.centerY); mergeCtx.rotate(coords.rotation); 
                    const scaledWidth = coords.width * coords.scale; const scaledHeight = coords.height * coords.scale; 
                    mergeCtx.beginPath(); 
                    if (coords.shape === 'circle') { mergeCtx.ellipse(0, 0, scaledWidth/2, scaledHeight/2, 0, 0, 2*Math.PI); } else { mergeCtx.rect(-scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight); }
                    mergeCtx.clip(); 
                    const targetW = scaledWidth; const targetH = scaledHeight; const targetAspect = targetW / targetH; const sourceW = img.width; const sourceH = img.height; const sourceAspect = sourceW / sourceH; 
                    let sX = 0, sY = 0, sW = sourceW, sH = sourceH; 
                    if (sourceAspect > targetAspect) { sH = sourceH; sW = sourceH * targetAspect; sX = (sourceW - sW) / 2; } else { sW = sourceW; sH = sourceW / targetAspect; sY = (sourceH - sH) / 2; } 
                    mergeCtx.drawImage(img, sX, sY, sW, sH, -targetW / 2, -targetH / 2, targetW, targetH); mergeCtx.restore(); 
                });
                mergeCtx.drawImage(templateImage, 0, 0, templateW, templateH);
                finalizeDraw();
            }

            function getPreviewCursorState(e) {
                const rect = mergeCanvas.getBoundingClientRect(); const scaleX = mergeCanvas.width / rect.width; const scaleY = mergeCanvas.height / rect.height; const x = (e.clientX - rect.left) * scaleX; const y = (e.clientY - rect.top) * scaleY; let hitIndex = -1;
                if (useTemplate) { for (let i = 0; i < photoSlots.length; i++) { const s = photoSlots[i]; const slotScale = s.scale || 1; const halfW = (s.width * slotScale) / 2; const halfH = (s.height * slotScale) / 2; const dx = x - s.centerX; const dy = y - s.centerY; const rx = dx * Math.cos(-s.rotation) - dy * Math.sin(-s.rotation); const ry = dx * Math.sin(-s.rotation) + dy * Math.cos(-s.rotation); if (Math.abs(rx) < halfW && Math.abs(ry) < halfH) { hitIndex = i; break; } } } 
                else { const slotHeight = mergeCanvas.height / numPhotosToTake; const clickedIndex = Math.floor(y / slotHeight); if (clickedIndex >= 0 && clickedIndex < numPhotosToTake) { hitIndex = clickedIndex; } }
                return hitIndex;
            }
            mergeCanvas.addEventListener('mousemove', (e) => { const hit = getPreviewCursorState(e); mergeCanvas.style.cursor = (hit !== -1) ? 'pointer' : 'default'; });
            
            mergeCanvas.addEventListener('click', (e) => { 
                const hitIndex = getPreviewCursorState(e); 
                if (hitIndex !== -1) { 
                    confirmMsg.textContent = `Retake Photo ${hitIndex + 1}?`; 
                    confirmModal.style.display = 'flex'; 
                    onConfirmAction = () => {
                        retakeIndex = hitIndex; 
                        showView('camera'); 
                        startCamera();
                    };
                } 
            });

            confirmYes.onclick = () => { 
                confirmModal.style.display = 'none'; 
                if (onConfirmAction) {
                    onConfirmAction(); 
                    onConfirmAction = null; 
                }
            };
            
            confirmNo.onclick = () => { 
                confirmModal.style.display = 'none'; 
                onConfirmAction = null; 
            };

            retakeBtn.addEventListener('click', () => { retakeIndex = null; showView('camera'); startCamera(); });
            remapBtn.addEventListener('click', () => { if (useTemplate) { showView('mapping'); setupMappingView(); } });
            
            homeBtn.addEventListener('click', () => {
                capturedPhotos = [];
                photoCount = 0;
                retakeIndex = null;
                showView('template');
            });

            saveBtn.addEventListener('click', () => { 
                const link = document.createElement('a'); 
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                link.download = `photobooth_pro_${timestamp}.png`; 
                const imageData = mergeCanvas.toDataURL('image/png');
                link.href = imageData; 
                link.click(); 

                showNotification("Saved!", imageData);
            });
            
            closePreviewBtn.addEventListener('click', () => { 
                showView('template'); 
                if (returnToGallery) {
                    galleryModal.style.display = 'flex'; 
                    returnToGallery = false; 
                }
            }); 
            
            changeTemplateBtn.addEventListener('click', () => { showView('template'); });
            undoBtn.addEventListener('click', () => { if (photoSlots.length > 0) { const popped = photoSlots.pop(); undoStack.push(popped); mappingState.selectedIndex = -1; updateMappingInstructions(); drawCurrentMapping(); updateButtonStates(); } });
            resetMappingBtn.addEventListener('click', () => { photoSlots = []; setupMappingView(); });
            startMappedBtn.addEventListener('click', () => { if (photoSlots.length === numPhotosToTake) { saveState(); showView('camera'); startCamera(); } });
            
            printBtn.addEventListener('click', () => {
                // Stats: Update Prints
                stats.prints++;
                saveStats();

                const oldFrame = document.getElementById('print-iframe');
                if (oldFrame) document.body.removeChild(oldFrame);
                const iframe = document.createElement('iframe');
                iframe.id = 'print-iframe';
                iframe.style.position = 'fixed';
                iframe.style.right = '0';
                iframe.style.bottom = '0';
                iframe.style.width = '0';
                iframe.style.height = '0';
                iframe.style.border = '0';
                document.body.appendChild(iframe);

                const isStrip = mergeCanvas.width / mergeCanvas.height < 0.5; 
                let imgData;

                if (isStrip) {
                    const pCanvas = document.createElement('canvas');
                    pCanvas.width = mergeCanvas.width * 2 + 100; // Add gap
                    pCanvas.height = mergeCanvas.height;
                    const pCtx = pCanvas.getContext('2d');
                    pCtx.fillStyle = 'white'; pCtx.fillRect(0,0,pCanvas.width,pCanvas.height);
                    pCtx.drawImage(mergeCanvas, 0, 0);
                    pCtx.drawImage(mergeCanvas, mergeCanvas.width + 100, 0);
                    imgData = pCanvas.toDataURL();
                } else {
                    imgData = mergeCanvas.toDataURL();
                }

                const doc = iframe.contentWindow.document;
                doc.open();
                doc.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Print Photo</title>
                        <style>
                            @page { margin: 0; size: auto; }
                            body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; }
                            img { max-width: 100%; max-height: 100%; object-fit: contain; }
                        </style>
                    </head>
                    <body>
                        <img src="${imgData}" onload="setTimeout(() => { window.print(); }, 500);">
                    </body>
                    </html>
                `);
                doc.close();
            });

            checkSession(); 
            enumerateCameras(); 
            window.addEventListener('resize', () => { if (views.mapping.style.display === 'flex' && templateImage.src) setupMappingView(); if (views.camera.style.display === 'flex') updateCameraCropVisual(); });
            
            setTimeout(() => {
                const lc = document.getElementById('login-card');
                if(lc) lc.classList.remove('initial-slide');
            }, 800); 
        });
    </script>
</body>
</html>
